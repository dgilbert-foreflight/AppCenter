// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct DistributionGroupWithUsersResponse: Codable, Identifiable {
  /// The unique ID of the distribution group
  public var id: UUID
  /// The name of the distribution group used in URLs
  public var name: String
  /// The count of users in the distribution group
  public var totalUserCount: Double
  /// The count of aad groups in the distribution group
  public var totalGroupsCount: Double?
  /// The count of non-pending users in the distribution group who will be notified by new releases
  public var notifiedUserCount: Double
  /// Whether the distribution group is public
  public var isPublic: Bool?
  /// The distribution group users
  public var users: [User]
  /// The distribution group aad groups
  public var aadGroups: [AadGroup]?

  public struct User: Codable, Identifiable {
    /// The unique id (UUID) of the user
    public var id: UUID?
    /// The avatar URL of the user
    public var avatarURL: String?
    /// User is required to send an old password in order to change the password.
    public var canChangePassword: Bool?
    /// The full name of the user. Might for example be first and last name
    public var displayName: String?
    /// The email address of the user
    public var email: String
    /// Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".
    public var isInvitePending: Bool?
    /// The unique name that is used to identify the user.
    public var name: String?

    public init(id: UUID? = nil, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String? = nil, email: String, isInvitePending: Bool? = nil, name: String? = nil) {
      self.id = id
      self.avatarURL = avatarURL
      self.canChangePassword = canChangePassword
      self.displayName = displayName
      self.email = email
      self.isInvitePending = isInvitePending
      self.name = name
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.id = try values.decodeIfPresent(UUID.self, forKey: "id")
      self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
      self.canChangePassword = try values.decodeIfPresent(Bool.self, forKey: "can_change_password")
      self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
      self.email = try values.decode(String.self, forKey: "email")
      self.isInvitePending = try values.decodeIfPresent(Bool.self, forKey: "invite_pending")
      self.name = try values.decodeIfPresent(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encodeIfPresent(id, forKey: "id")
      try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
      try values.encodeIfPresent(canChangePassword, forKey: "can_change_password")
      try values.encodeIfPresent(displayName, forKey: "display_name")
      try values.encode(email, forKey: "email")
      try values.encodeIfPresent(isInvitePending, forKey: "invite_pending")
      try values.encodeIfPresent(name, forKey: "name")
    }
  }

  public struct AadGroup: Codable, Identifiable {
    /// The internal unique id (UUID) of the AAD group.
    public var id: UUID?
    /// The AAD unique id (UUID) of the AAD group.
    public var aadGroupID: UUID?
    /// The display name of the AAD group
    public var displayName: String?

    public init(id: UUID? = nil, aadGroupID: UUID? = nil, displayName: String? = nil) {
      self.id = id
      self.aadGroupID = aadGroupID
      self.displayName = displayName
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.id = try values.decodeIfPresent(UUID.self, forKey: "id")
      self.aadGroupID = try values.decodeIfPresent(UUID.self, forKey: "aad_group_id")
      self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encodeIfPresent(id, forKey: "id")
      try values.encodeIfPresent(aadGroupID, forKey: "aad_group_id")
      try values.encodeIfPresent(displayName, forKey: "display_name")
    }
  }

  public init(id: UUID, name: String, totalUserCount: Double, totalGroupsCount: Double? = nil, notifiedUserCount: Double, isPublic: Bool? = nil, users: [User], aadGroups: [AadGroup]? = nil) {
    self.id = id
    self.name = name
    self.totalUserCount = totalUserCount
    self.totalGroupsCount = totalGroupsCount
    self.notifiedUserCount = notifiedUserCount
    self.isPublic = isPublic
    self.users = users
    self.aadGroups = aadGroups
  }

  public init(from decoder: Decoder) throws {
    let values = try decoder.container(keyedBy: StringCodingKey.self)
    self.id = try values.decode(UUID.self, forKey: "id")
    self.name = try values.decode(String.self, forKey: "name")
    self.totalUserCount = try values.decode(Double.self, forKey: "total_user_count")
    self.totalGroupsCount = try values.decodeIfPresent(Double.self, forKey: "total_groups_count")
    self.notifiedUserCount = try values.decode(Double.self, forKey: "notified_user_count")
    self.isPublic = try values.decodeIfPresent(Bool.self, forKey: "is_public")
    self.users = try values.decode([User].self, forKey: "users")
    self.aadGroups = try values.decodeIfPresent([AadGroup].self, forKey: "aad_groups")
  }

  public func encode(to encoder: Encoder) throws {
    var values = encoder.container(keyedBy: StringCodingKey.self)
    try values.encode(id, forKey: "id")
    try values.encode(name, forKey: "name")
    try values.encode(totalUserCount, forKey: "total_user_count")
    try values.encodeIfPresent(totalGroupsCount, forKey: "total_groups_count")
    try values.encode(notifiedUserCount, forKey: "notified_user_count")
    try values.encodeIfPresent(isPublic, forKey: "is_public")
    try values.encode(users, forKey: "users")
    try values.encodeIfPresent(aadGroups, forKey: "aad_groups")
  }
}
