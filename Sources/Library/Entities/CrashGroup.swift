// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct CrashGroup: Codable {
  public var crashGroupID: String
  public var newCrashGroupID: String
  public var displayID: String
  public var appVersion: String
  public var build: String
  public var status: Status
  public var count: Int
  public var impactedUsers: Int?
  public var firstOccurrence: Date
  public var lastOccurrence: Date
  public var exception: String?
  public var crashReason: String
  /// Frame belonging to the reason of the crash
  public var reasonFrame: ReasonFrame?
  /// Crash or handled exception
  public var isFatal: Bool
  public var annotation: String

  public enum Status: String, Codable, CaseIterable {
    case `open`
    case closed
    case ignored
  }

  /// Frame belonging to the reason of the crash
  public struct ReasonFrame: Codable {
    /// Name of the class
    public var className: String?
    /// Name of the method
    public var method: String?
    /// Is a class method
    public var isClassMethod: Bool?
    /// Name of the file
    public var file: String?
    /// Line number
    public var line: Int?
    /// This line isn't from any framework
    public var isAppCode: Bool?
    /// Name of the framework
    public var frameworkName: String?
    /// Formatted frame string
    public var codeFormatted: String?
    /// Unformatted Frame string
    public var codeRaw: String?
    /// Programming language of the frame
    public var language: Language?
    /// Parameters of the frames method
    public var methodParams: String?
    /// Exception type.
    public var exceptionType: String?
    /// OS exception type. (aka. SIGNAL)
    public var osExceptionType: String?

    /// Programming language of the frame
    public enum Language: String, Codable, CaseIterable {
      case javaScript = "JavaScript"
      case cSharp = "CSharp"
      case objectiveC = "Objective-C"
      case objectiveCpp = "Objective-Cpp"
      case cpp = "Cpp"
      case c = "C"
      case swift = "Swift"
      case java = "Java"
      case unknown = "Unknown"
    }

    public init(className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool? = nil, frameworkName: String? = nil, codeFormatted: String? = nil, codeRaw: String? = nil, language: Language? = nil, methodParams: String? = nil, exceptionType: String? = nil, osExceptionType: String? = nil) {
      self.className = className
      self.method = method
      self.isClassMethod = isClassMethod
      self.file = file
      self.line = line
      self.isAppCode = isAppCode
      self.frameworkName = frameworkName
      self.codeFormatted = codeFormatted
      self.codeRaw = codeRaw
      self.language = language
      self.methodParams = methodParams
      self.exceptionType = exceptionType
      self.osExceptionType = osExceptionType
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.className = try values.decodeIfPresent(String.self, forKey: "class_name")
      self.method = try values.decodeIfPresent(String.self, forKey: "method")
      self.isClassMethod = try values.decodeIfPresent(Bool.self, forKey: "class_method")
      self.file = try values.decodeIfPresent(String.self, forKey: "file")
      self.line = try values.decodeIfPresent(Int.self, forKey: "line")
      self.isAppCode = try values.decodeIfPresent(Bool.self, forKey: "app_code")
      self.frameworkName = try values.decodeIfPresent(String.self, forKey: "framework_name")
      self.codeFormatted = try values.decodeIfPresent(String.self, forKey: "code_formatted")
      self.codeRaw = try values.decodeIfPresent(String.self, forKey: "code_raw")
      self.language = try values.decodeIfPresent(Language.self, forKey: "language")
      self.methodParams = try values.decodeIfPresent(String.self, forKey: "method_params")
      self.exceptionType = try values.decodeIfPresent(String.self, forKey: "exception_type")
      self.osExceptionType = try values.decodeIfPresent(String.self, forKey: "os_exception_type")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encodeIfPresent(className, forKey: "class_name")
      try values.encodeIfPresent(method, forKey: "method")
      try values.encodeIfPresent(isClassMethod, forKey: "class_method")
      try values.encodeIfPresent(file, forKey: "file")
      try values.encodeIfPresent(line, forKey: "line")
      try values.encodeIfPresent(isAppCode, forKey: "app_code")
      try values.encodeIfPresent(frameworkName, forKey: "framework_name")
      try values.encodeIfPresent(codeFormatted, forKey: "code_formatted")
      try values.encodeIfPresent(codeRaw, forKey: "code_raw")
      try values.encodeIfPresent(language, forKey: "language")
      try values.encodeIfPresent(methodParams, forKey: "method_params")
      try values.encodeIfPresent(exceptionType, forKey: "exception_type")
      try values.encodeIfPresent(osExceptionType, forKey: "os_exception_type")
    }
  }

  public init(crashGroupID: String, newCrashGroupID: String, displayID: String, appVersion: String, build: String, status: Status, count: Int, impactedUsers: Int? = nil, firstOccurrence: Date, lastOccurrence: Date, exception: String? = nil, crashReason: String, reasonFrame: ReasonFrame? = nil, isFatal: Bool, annotation: String) {
    self.crashGroupID = crashGroupID
    self.newCrashGroupID = newCrashGroupID
    self.displayID = displayID
    self.appVersion = appVersion
    self.build = build
    self.status = status
    self.count = count
    self.impactedUsers = impactedUsers
    self.firstOccurrence = firstOccurrence
    self.lastOccurrence = lastOccurrence
    self.exception = exception
    self.crashReason = crashReason
    self.reasonFrame = reasonFrame
    self.isFatal = isFatal
    self.annotation = annotation
  }

  public init(from decoder: Decoder) throws {
    let values = try decoder.container(keyedBy: StringCodingKey.self)
    self.crashGroupID = try values.decode(String.self, forKey: "crash_group_id")
    self.newCrashGroupID = try values.decode(String.self, forKey: "new_crash_group_id")
    self.displayID = try values.decode(String.self, forKey: "display_id")
    self.appVersion = try values.decode(String.self, forKey: "app_version")
    self.build = try values.decode(String.self, forKey: "build")
    self.status = try values.decode(Status.self, forKey: "status")
    self.count = try values.decode(Int.self, forKey: "count")
    self.impactedUsers = try values.decodeIfPresent(Int.self, forKey: "impacted_users")
    self.firstOccurrence = try values.decode(Date.self, forKey: "first_occurrence")
    self.lastOccurrence = try values.decode(Date.self, forKey: "last_occurrence")
    self.exception = try values.decodeIfPresent(String.self, forKey: "exception")
    self.crashReason = try values.decode(String.self, forKey: "crash_reason")
    self.reasonFrame = try values.decodeIfPresent(ReasonFrame.self, forKey: "reason_frame")
    self.isFatal = try values.decode(Bool.self, forKey: "fatal")
    self.annotation = try values.decode(String.self, forKey: "annotation")
  }

  public func encode(to encoder: Encoder) throws {
    var values = encoder.container(keyedBy: StringCodingKey.self)
    try values.encode(crashGroupID, forKey: "crash_group_id")
    try values.encode(newCrashGroupID, forKey: "new_crash_group_id")
    try values.encode(displayID, forKey: "display_id")
    try values.encode(appVersion, forKey: "app_version")
    try values.encode(build, forKey: "build")
    try values.encode(status, forKey: "status")
    try values.encode(count, forKey: "count")
    try values.encodeIfPresent(impactedUsers, forKey: "impacted_users")
    try values.encode(firstOccurrence, forKey: "first_occurrence")
    try values.encode(lastOccurrence, forKey: "last_occurrence")
    try values.encodeIfPresent(exception, forKey: "exception")
    try values.encode(crashReason, forKey: "crash_reason")
    try values.encodeIfPresent(reasonFrame, forKey: "reason_frame")
    try values.encode(isFatal, forKey: "fatal")
    try values.encode(annotation, forKey: "annotation")
  }
}
