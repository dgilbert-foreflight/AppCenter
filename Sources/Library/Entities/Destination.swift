// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct Destination: Codable, Identifiable {
  public var a: A
  public var b: B
  /// Name of a distribution group / distribution store. The release will be associated with this distribution group or store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
  public var name: String?
  /// Id of a distribution group / store. The release will be associated with this distribution group / store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
  public var id: String?
  /// Destination can be either store or group.
  public var destinationType: DestinationType?
  /// Display name for the group or tester
  public var displayName: String?

  public struct A: Codable, Identifiable {
    /// ID identifying a unique distribution group.
    public var id: String
    /// A name identifying a unique distribution group.
    public var name: String?
    /// Is the containing release the latest one in this distribution group.
    public var isLatest: Bool?

    public init(id: String, name: String? = nil, isLatest: Bool? = nil) {
      self.id = id
      self.name = name
      self.isLatest = isLatest
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.id = try values.decode(String.self, forKey: "id")
      self.name = try values.decodeIfPresent(String.self, forKey: "name")
      self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encode(id, forKey: "id")
      try values.encodeIfPresent(name, forKey: "name")
      try values.encodeIfPresent(isLatest, forKey: "is_latest")
    }
  }

  public struct B: Codable, Identifiable {
    /// ID identifying a unique distribution store.
    public var id: String
    /// A name identifying a unique distribution store.
    public var name: String?
    /// Type of the distribution store currently stores type can be intune, googleplay or windows.
    public var type: `Type`?
    /// Publishing status of the release in the store.
    public var publishingStatus: String?
    /// Is the containing release the latest one in this distribution store.
    public var isLatest: Bool?

    /// Type of the distribution store currently stores type can be intune, googleplay or windows.
    public enum `Type`: String, Codable, CaseIterable {
      case intune
      case googleplay
      case apple
      case `none`
    }

    public init(id: String, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil, isLatest: Bool? = nil) {
      self.id = id
      self.name = name
      self.type = type
      self.publishingStatus = publishingStatus
      self.isLatest = isLatest
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.id = try values.decode(String.self, forKey: "id")
      self.name = try values.decodeIfPresent(String.self, forKey: "name")
      self.type = try values.decodeIfPresent(`Type`.self, forKey: "type")
      self.publishingStatus = try values.decodeIfPresent(String.self, forKey: "publishing_status")
      self.isLatest = try values.decodeIfPresent(Bool.self, forKey: "is_latest")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encode(id, forKey: "id")
      try values.encodeIfPresent(name, forKey: "name")
      try values.encodeIfPresent(type, forKey: "type")
      try values.encodeIfPresent(publishingStatus, forKey: "publishing_status")
      try values.encodeIfPresent(isLatest, forKey: "is_latest")
    }
  }

  /// Destination can be either store or group.
  public enum DestinationType: String, Codable, CaseIterable {
    case group
    case store
    case tester
  }

  public init(a: A, b: B, name: String? = nil, id: String? = nil, destinationType: DestinationType? = nil, displayName: String? = nil) {
    self.a = a
    self.b = b
    self.name = name
    self.id = id
    self.destinationType = destinationType
    self.displayName = displayName
  }

  public init(from decoder: Decoder) throws {
    let values = try decoder.container(keyedBy: StringCodingKey.self)
    self.a = try values.decode(A.self, forKey: "a")
    self.b = try values.decode(B.self, forKey: "b")
    self.name = try values.decodeIfPresent(String.self, forKey: "name")
    self.id = try values.decodeIfPresent(String.self, forKey: "id")
    self.destinationType = try values.decodeIfPresent(DestinationType.self, forKey: "destination_type")
    self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
  }

  public func encode(to encoder: Encoder) throws {
    var values = encoder.container(keyedBy: StringCodingKey.self)
    try values.encode(a, forKey: "a")
    try values.encode(b, forKey: "b")
    try values.encodeIfPresent(name, forKey: "name")
    try values.encodeIfPresent(id, forKey: "id")
    try values.encodeIfPresent(destinationType, forKey: "destination_type")
    try values.encodeIfPresent(displayName, forKey: "display_name")
  }
}
