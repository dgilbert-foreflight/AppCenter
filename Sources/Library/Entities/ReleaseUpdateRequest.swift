// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// A request containing information for updating a release.
public struct ReleaseUpdateRequest: Codable {
  /// OBSOLETE. Will be removed in future releases - use destinations instead. Name of a distribution group. The release will be associated with this distribution group. If the distribution group doesn't exist a 400 is returned. If both distribution group name and id are passed, the id is taking precedence.
  public var distributionGroupName: String?
  /// OBSOLETE. Will be removed in future releases - use destinations instead. Id of a distribution group. The release will be associated with this distribution group. If the distribution group doesn't exist a 400 is returned. If both distribution group name and id are passed, the id is taking precedence.
  public var distributionGroupID: String?
  /// OBSOLETE. Will be removed in future releases - use destinations instead. Name of a destination. The release will be associated with this destination. If the destination doesn't exist a 400 is returned. If both distribution group name and id are passed, the id is taking precedence.
  public var destinationName: String?
  /// OBSOLETE. Will be removed in future releases - use destinations instead. Id of a destination. The release will be associated with this destination. If the destination doesn't exist a 400 is returned. If both destination name and id are passed, the id is taking precedence.
  public var destinationID: String?
  /// Not used anymore.
  public var destinationType: String?
  /// Release notes for this release.
  public var releaseNotes: String?
  /// A boolean which determines whether this version should be a mandatory update or not.
  public var isMandatoryUpdate: Bool?
  /// Distribute this release under the following list of destinations (store groups or distribution groups).
  public var destinations: [Destination]?
  /// Contains metadata about the build that produced the release being uploaded
  public var build: Build?
  /// A boolean which determines whether to notify testers of a new release, default to true.
  public var isNotifyTesters: Bool
  /// An object containing all the release metadata.
  public var metadata: Metadata?

  /// A unique identifier for a destination. A destination can be identified by an ID (guid) or by a name. DestinationId encapsulates both options. A destination can be either a distribution group or a store.
  public struct Destination: Codable, Identifiable {
    /// Name of a distribution group / distribution store. The release will be associated with this distribution group or store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
    public var name: String?
    /// Id of a distribution group / store. The release will be associated with this distribution group / store. If the distribution group / store doesn't exist a 400 is returned. If both distribution group / store name and id are passed, the id is taking precedence.
    public var id: String?

    public init(name: String? = nil, id: String? = nil) {
      self.name = name
      self.id = id
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.name = try values.decodeIfPresent(String.self, forKey: "name")
      self.id = try values.decodeIfPresent(String.self, forKey: "id")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encodeIfPresent(name, forKey: "name")
      try values.encodeIfPresent(id, forKey: "id")
    }
  }

  /// Contains metadata about the build that produced the release being uploaded
  public struct Build: Codable {
    /// The branch name of the build producing the release
    public var branchName: String?
    /// The commit hash of the build producing the release
    public var commitHash: String?
    /// The commit message of the build producing the release
    public var commitMessage: String?

    public init(branchName: String? = nil, commitHash: String? = nil, commitMessage: String? = nil) {
      self.branchName = branchName
      self.commitHash = commitHash
      self.commitMessage = commitMessage
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.branchName = try values.decodeIfPresent(String.self, forKey: "branch_name")
      self.commitHash = try values.decodeIfPresent(String.self, forKey: "commit_hash")
      self.commitMessage = try values.decodeIfPresent(String.self, forKey: "commit_message")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encodeIfPresent(branchName, forKey: "branch_name")
      try values.encodeIfPresent(commitHash, forKey: "commit_hash")
      try values.encodeIfPresent(commitMessage, forKey: "commit_message")
    }
  }

  /// An object containing all the release metadata.
  public struct Metadata: Codable {
    /// Dsa signature of the release for the sparkle feed.
    public var dsaSignature: String?
    /// EdDSA signature of the release for the sparkle feed.
    public var edSignature: String?

    public init(dsaSignature: String? = nil, edSignature: String? = nil) {
      self.dsaSignature = dsaSignature
      self.edSignature = edSignature
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.dsaSignature = try values.decodeIfPresent(String.self, forKey: "dsa_signature")
      self.edSignature = try values.decodeIfPresent(String.self, forKey: "ed_signature")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encodeIfPresent(dsaSignature, forKey: "dsa_signature")
      try values.encodeIfPresent(edSignature, forKey: "ed_signature")
    }
  }

  public init(distributionGroupName: String? = nil, distributionGroupID: String? = nil, destinationName: String? = nil, destinationID: String? = nil, destinationType: String? = nil, releaseNotes: String? = nil, isMandatoryUpdate: Bool? = nil, destinations: [Destination]? = nil, build: Build? = nil, isNotifyTesters: Bool? = nil, metadata: Metadata? = nil) {
    self.distributionGroupName = distributionGroupName
    self.distributionGroupID = distributionGroupID
    self.destinationName = destinationName
    self.destinationID = destinationID
    self.destinationType = destinationType
    self.releaseNotes = releaseNotes
    self.isMandatoryUpdate = isMandatoryUpdate
    self.destinations = destinations
    self.build = build
    self.isNotifyTesters = isNotifyTesters ?? true
    self.metadata = metadata
  }

  public init(from decoder: Decoder) throws {
    let values = try decoder.container(keyedBy: StringCodingKey.self)
    self.distributionGroupName = try values.decodeIfPresent(String.self, forKey: "distribution_group_name")
    self.distributionGroupID = try values.decodeIfPresent(String.self, forKey: "distribution_group_id")
    self.destinationName = try values.decodeIfPresent(String.self, forKey: "destination_name")
    self.destinationID = try values.decodeIfPresent(String.self, forKey: "destination_id")
    self.destinationType = try values.decodeIfPresent(String.self, forKey: "destination_type")
    self.releaseNotes = try values.decodeIfPresent(String.self, forKey: "release_notes")
    self.isMandatoryUpdate = try values.decodeIfPresent(Bool.self, forKey: "mandatory_update")
    self.destinations = try values.decodeIfPresent([Destination].self, forKey: "destinations")
    self.build = try values.decodeIfPresent(Build.self, forKey: "build")
    self.isNotifyTesters = try values.decodeIfPresent(Bool.self, forKey: "notify_testers") ?? true
    self.metadata = try values.decodeIfPresent(Metadata.self, forKey: "metadata")
  }

  public func encode(to encoder: Encoder) throws {
    var values = encoder.container(keyedBy: StringCodingKey.self)
    try values.encodeIfPresent(distributionGroupName, forKey: "distribution_group_name")
    try values.encodeIfPresent(distributionGroupID, forKey: "distribution_group_id")
    try values.encodeIfPresent(destinationName, forKey: "destination_name")
    try values.encodeIfPresent(destinationID, forKey: "destination_id")
    try values.encodeIfPresent(destinationType, forKey: "destination_type")
    try values.encodeIfPresent(releaseNotes, forKey: "release_notes")
    try values.encodeIfPresent(isMandatoryUpdate, forKey: "mandatory_update")
    try values.encodeIfPresent(destinations, forKey: "destinations")
    try values.encodeIfPresent(build, forKey: "build")
    try values.encodeIfPresent(isNotifyTesters, forKey: "notify_testers")
    try values.encodeIfPresent(metadata, forKey: "metadata")
  }
}
