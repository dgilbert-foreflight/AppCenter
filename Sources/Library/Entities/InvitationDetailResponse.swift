// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct InvitationDetailResponse: Codable {
  /// The id of the invitation
  public var invitationID: UUID
  public var invitedBy: InvitedBy
  public var organization: Organization?
  public var app: App?

  public struct InvitedBy: Codable, Identifiable {
    /// The unique id (UUID) of the user
    public var id: UUID
    /// The avatar URL of the user
    public var avatarURL: String?
    /// User is required to send an old password in order to change the password.
    public var canChangePassword: Bool?
    /// The full name of the user. Might for example be first and last name
    public var displayName: String
    /// The email address of the user
    public var email: String
    /// The unique name that is used to identify the user.
    public var name: String
    /// The permissions the user has for the app
    public var permissions: [Permission]?
    /// The creation origin of this user
    public var origin: Origin

    public enum Permission: String, Codable, CaseIterable {
      case manager
      case developer
      case viewer
      case tester
    }

    /// The creation origin of this user
    public enum Origin: String, Codable, CaseIterable {
      case appcenter
      case hockeyapp
      case codepush
    }

    public init(id: UUID, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String, email: String, name: String, permissions: [Permission]? = nil, origin: Origin) {
      self.id = id
      self.avatarURL = avatarURL
      self.canChangePassword = canChangePassword
      self.displayName = displayName
      self.email = email
      self.name = name
      self.permissions = permissions
      self.origin = origin
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.id = try values.decode(UUID.self, forKey: "id")
      self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
      self.canChangePassword = try values.decodeIfPresent(Bool.self, forKey: "can_change_password")
      self.displayName = try values.decode(String.self, forKey: "display_name")
      self.email = try values.decode(String.self, forKey: "email")
      self.name = try values.decode(String.self, forKey: "name")
      self.permissions = try values.decodeIfPresent([Permission].self, forKey: "permissions")
      self.origin = try values.decode(Origin.self, forKey: "origin")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encode(id, forKey: "id")
      try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
      try values.encodeIfPresent(canChangePassword, forKey: "can_change_password")
      try values.encode(displayName, forKey: "display_name")
      try values.encode(email, forKey: "email")
      try values.encode(name, forKey: "name")
      try values.encodeIfPresent(permissions, forKey: "permissions")
      try values.encode(origin, forKey: "origin")
    }
  }

  public struct Organization: Codable, Identifiable {
    /// The internal unique id (UUID) of the organization.
    public var id: UUID
    /// The display name of the organization
    public var displayName: String
    /// The slug name of the organization
    public var name: String
    /// The URL to a user-uploaded Avatar image
    public var avatarURL: String?
    /// The creation origin of this organization
    public var origin: Origin
    /// The creation date of this organization
    public var createdAt: String
    /// The date the organization was last updated at
    public var updatedAt: String

    /// The creation origin of this organization
    public enum Origin: String, Codable, CaseIterable {
      case appcenter
      case hockeyapp
    }

    public init(id: UUID, displayName: String, name: String, avatarURL: String? = nil, origin: Origin, createdAt: String, updatedAt: String) {
      self.id = id
      self.displayName = displayName
      self.name = name
      self.avatarURL = avatarURL
      self.origin = origin
      self.createdAt = createdAt
      self.updatedAt = updatedAt
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.id = try values.decode(UUID.self, forKey: "id")
      self.displayName = try values.decode(String.self, forKey: "display_name")
      self.name = try values.decode(String.self, forKey: "name")
      self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
      self.origin = try values.decode(Origin.self, forKey: "origin")
      self.createdAt = try values.decode(String.self, forKey: "created_at")
      self.updatedAt = try values.decode(String.self, forKey: "updated_at")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encode(id, forKey: "id")
      try values.encode(displayName, forKey: "display_name")
      try values.encode(name, forKey: "name")
      try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
      try values.encode(origin, forKey: "origin")
      try values.encode(createdAt, forKey: "created_at")
      try values.encode(updatedAt, forKey: "updated_at")
    }
  }

  public struct App: Codable, Identifiable {
    /// The unique ID (UUID) of the app
    public var id: UUID
    /// The description of the app
    public var description: String?
    /// The display name of the app
    public var displayName: String
    /// A one-word descriptive release-type value that starts with a capital letter but is otherwise lowercase
    public var releaseType: String?
    /// The string representation of the URL pointing to the app's icon
    public var iconURL: String?
    /// The string representation of the source of the app's icon
    public var iconSource: String?
    /// The name of the app used in URLs
    public var name: String
    /// The OS the app will be running on
    public var os: Os
    /// The information about the app's owner
    public var owner: Owner
    /// A unique and secret key used to identify the app in communication with the ingestion endpoint for crash reporting and analytics
    public var appSecret: String?
    public var azureSubscription: AzureSubscription?
    /// The platform of the app
    public var platform: Platform?
    /// The creation origin of this app
    public var origin: Origin?
    /// The created date of this app
    public var createdAt: String?
    /// The last updated date of this app
    public var updatedAt: String?
    /// The permissions of the calling user
    public var memberPermissions: [MemberPermission]?

    /// The OS the app will be running on
    public enum Os: String, Codable, CaseIterable {
      case android = "Android"
      case iOS
      case macOS
      case tizen = "Tizen"
      case tvOS
      case windows = "Windows"
      case linux = "Linux"
      case custom = "Custom"
    }

    /// The information about the app's owner
    public struct Owner: Codable, Identifiable {
      /// The unique id (UUID) of the owner
      public var id: UUID
      /// The avatar URL of the owner
      public var avatarURL: String?
      /// The owner's display name
      public var displayName: String
      /// The owner's email address
      public var email: String?
      /// The unique name that used to identify the owner
      public var name: String
      /// The owner type. Can either be 'org' or 'user'
      public var type: `Type`

      /// The owner type. Can either be 'org' or 'user'
      public enum `Type`: String, Codable, CaseIterable {
        case org
        case user
      }

      public init(id: UUID, avatarURL: String? = nil, displayName: String, email: String? = nil, name: String, type: `Type`) {
        self.id = id
        self.avatarURL = avatarURL
        self.displayName = displayName
        self.email = email
        self.name = name
        self.type = type
      }

      public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(UUID.self, forKey: "id")
        self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
        self.displayName = try values.decode(String.self, forKey: "display_name")
        self.email = try values.decodeIfPresent(String.self, forKey: "email")
        self.name = try values.decode(String.self, forKey: "name")
        self.type = try values.decode(`Type`.self, forKey: "type")
      }

      public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
        try values.encode(displayName, forKey: "display_name")
        try values.encodeIfPresent(email, forKey: "email")
        try values.encode(name, forKey: "name")
        try values.encode(type, forKey: "type")
      }
    }

    public struct AzureSubscription: Codable {
      /// The azure subscription id
      public var subscriptionID: UUID
      /// The tenant id of the azure subscription belongs to
      public var tenantID: UUID
      /// The name of the azure subscription
      public var subscriptionName: String
      /// If the subscription is used for billing
      public var isBilling: Bool?
      /// If the subscription can be used for billing
      public var isBillable: Bool?
      /// If the subscription is internal Microsoft subscription
      public var isMicrosoftInternal: Bool?

      public init(subscriptionID: UUID, tenantID: UUID, subscriptionName: String, isBilling: Bool? = nil, isBillable: Bool? = nil, isMicrosoftInternal: Bool? = nil) {
        self.subscriptionID = subscriptionID
        self.tenantID = tenantID
        self.subscriptionName = subscriptionName
        self.isBilling = isBilling
        self.isBillable = isBillable
        self.isMicrosoftInternal = isMicrosoftInternal
      }

      public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.subscriptionID = try values.decode(UUID.self, forKey: "subscription_id")
        self.tenantID = try values.decode(UUID.self, forKey: "tenant_id")
        self.subscriptionName = try values.decode(String.self, forKey: "subscription_name")
        self.isBilling = try values.decodeIfPresent(Bool.self, forKey: "is_billing")
        self.isBillable = try values.decodeIfPresent(Bool.self, forKey: "is_billable")
        self.isMicrosoftInternal = try values.decodeIfPresent(Bool.self, forKey: "is_microsoft_internal")
      }

      public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(subscriptionID, forKey: "subscription_id")
        try values.encode(tenantID, forKey: "tenant_id")
        try values.encode(subscriptionName, forKey: "subscription_name")
        try values.encodeIfPresent(isBilling, forKey: "is_billing")
        try values.encodeIfPresent(isBillable, forKey: "is_billable")
        try values.encodeIfPresent(isMicrosoftInternal, forKey: "is_microsoft_internal")
      }
    }

    /// The platform of the app
    public enum Platform: String, Codable, CaseIterable {
      case java = "Java"
      case objectiveCSwift = "Objective-C-Swift"
      case uwp = "UWP"
      case cordova = "Cordova"
      case reactNative = "React-Native"
      case unity = "Unity"
      case electron = "Electron"
      case xamarin = "Xamarin"
      case wpf = "WPF"
      case winForms = "WinForms"
      case unknown = "Unknown"
      case custom = "Custom"
    }

    /// The creation origin of this app
    public enum Origin: String, Codable, CaseIterable {
      case appcenter
      case hockeyapp
      case codepush
    }

    public enum MemberPermission: String, Codable, CaseIterable {
      case manager
      case developer
      case viewer
      case tester
    }

    public init(id: UUID, description: String? = nil, displayName: String, releaseType: String? = nil, iconURL: String? = nil, iconSource: String? = nil, name: String, os: Os, owner: Owner, appSecret: String? = nil, azureSubscription: AzureSubscription? = nil, platform: Platform? = nil, origin: Origin? = nil, createdAt: String? = nil, updatedAt: String? = nil, memberPermissions: [MemberPermission]? = nil) {
      self.id = id
      self.description = description
      self.displayName = displayName
      self.releaseType = releaseType
      self.iconURL = iconURL
      self.iconSource = iconSource
      self.name = name
      self.os = os
      self.owner = owner
      self.appSecret = appSecret
      self.azureSubscription = azureSubscription
      self.platform = platform
      self.origin = origin
      self.createdAt = createdAt
      self.updatedAt = updatedAt
      self.memberPermissions = memberPermissions
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.id = try values.decode(UUID.self, forKey: "id")
      self.description = try values.decodeIfPresent(String.self, forKey: "description")
      self.displayName = try values.decode(String.self, forKey: "display_name")
      self.releaseType = try values.decodeIfPresent(String.self, forKey: "release_type")
      self.iconURL = try values.decodeIfPresent(String.self, forKey: "icon_url")
      self.iconSource = try values.decodeIfPresent(String.self, forKey: "icon_source")
      self.name = try values.decode(String.self, forKey: "name")
      self.os = try values.decode(Os.self, forKey: "os")
      self.owner = try values.decode(Owner.self, forKey: "owner")
      self.appSecret = try values.decodeIfPresent(String.self, forKey: "app_secret")
      self.azureSubscription = try values.decodeIfPresent(AzureSubscription.self, forKey: "azure_subscription")
      self.platform = try values.decodeIfPresent(Platform.self, forKey: "platform")
      self.origin = try values.decodeIfPresent(Origin.self, forKey: "origin")
      self.createdAt = try values.decodeIfPresent(String.self, forKey: "created_at")
      self.updatedAt = try values.decodeIfPresent(String.self, forKey: "updated_at")
      self.memberPermissions = try values.decodeIfPresent([MemberPermission].self, forKey: "member_permissions")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encode(id, forKey: "id")
      try values.encodeIfPresent(description, forKey: "description")
      try values.encode(displayName, forKey: "display_name")
      try values.encodeIfPresent(releaseType, forKey: "release_type")
      try values.encodeIfPresent(iconURL, forKey: "icon_url")
      try values.encodeIfPresent(iconSource, forKey: "icon_source")
      try values.encode(name, forKey: "name")
      try values.encode(os, forKey: "os")
      try values.encode(owner, forKey: "owner")
      try values.encodeIfPresent(appSecret, forKey: "app_secret")
      try values.encodeIfPresent(azureSubscription, forKey: "azure_subscription")
      try values.encodeIfPresent(platform, forKey: "platform")
      try values.encodeIfPresent(origin, forKey: "origin")
      try values.encodeIfPresent(createdAt, forKey: "created_at")
      try values.encodeIfPresent(updatedAt, forKey: "updated_at")
      try values.encodeIfPresent(memberPermissions, forKey: "member_permissions")
    }
  }

  public init(invitationID: UUID, invitedBy: InvitedBy, organization: Organization? = nil, app: App? = nil) {
    self.invitationID = invitationID
    self.invitedBy = invitedBy
    self.organization = organization
    self.app = app
  }

  public init(from decoder: Decoder) throws {
    let values = try decoder.container(keyedBy: StringCodingKey.self)
    self.invitationID = try values.decode(UUID.self, forKey: "invitation_id")
    self.invitedBy = try values.decode(InvitedBy.self, forKey: "invited_by")
    self.organization = try values.decodeIfPresent(Organization.self, forKey: "organization")
    self.app = try values.decodeIfPresent(App.self, forKey: "app")
  }

  public func encode(to encoder: Encoder) throws {
    var values = encoder.container(keyedBy: StringCodingKey.self)
    try values.encode(invitationID, forKey: "invitation_id")
    try values.encode(invitedBy, forKey: "invited_by")
    try values.encodeIfPresent(organization, forKey: "organization")
    try values.encodeIfPresent(app, forKey: "app")
  }
}
