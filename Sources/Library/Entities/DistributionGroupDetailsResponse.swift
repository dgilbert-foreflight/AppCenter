// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

public struct DistributionGroupDetailsResponse: Codable, Identifiable {
  /// The unique ID of the distribution group
  public var id: UUID
  /// The name of the distribution group used in URLs
  public var name: String
  /// The name of the distribution group
  public var displayName: String?
  /// The creation origin of this distribution group
  public var origin: Origin
  /// Whether the distribution group is public
  public var isPublic: Bool
  /// Whether the distribution group is shared group or not
  public var isShared: Bool?
  /// The count of apps associated with this distribution group
  public var totalAppsCount: Double?
  /// The count of users in the distribution group
  public var totalUserCount: Double?
  /// The count of non-pending users in the distribution group who will be notified by new releases
  public var notifiedUserCount: Double?
  /// Type of group (Default, HockeyAppDefault or MicrosoftDogfooding)
  public var groupType: GroupType?
  /// The distribution group users
  public var users: [User]?

  /// The creation origin of this distribution group
  public enum Origin: String, Codable, CaseIterable {
    case appcenter
    case hockeyapp
  }

  /// Type of group (Default, HockeyAppDefault or MicrosoftDogfooding)
  public enum GroupType: String, Codable, CaseIterable {
    case `default` = "Default"
    case hockeyAppDefault = "HockeyAppDefault"
    case microsoftDogfooding = "MicrosoftDogfooding"
  }

  public struct User: Codable, Identifiable {
    /// The unique id (UUID) of the user
    public var id: UUID?
    /// The avatar URL of the user
    public var avatarURL: String?
    /// User is required to send an old password in order to change the password.
    public var canChangePassword: Bool?
    /// The full name of the user. Might for example be first and last name
    public var displayName: String?
    /// The email address of the user
    public var email: String
    /// Whether the has accepted the invite. Available when an invite is pending, and the value will be "true".
    public var isInvitePending: Bool?
    /// The unique name that is used to identify the user.
    public var name: String?

    public init(id: UUID? = nil, avatarURL: String? = nil, canChangePassword: Bool? = nil, displayName: String? = nil, email: String, isInvitePending: Bool? = nil, name: String? = nil) {
      self.id = id
      self.avatarURL = avatarURL
      self.canChangePassword = canChangePassword
      self.displayName = displayName
      self.email = email
      self.isInvitePending = isInvitePending
      self.name = name
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.id = try values.decodeIfPresent(UUID.self, forKey: "id")
      self.avatarURL = try values.decodeIfPresent(String.self, forKey: "avatar_url")
      self.canChangePassword = try values.decodeIfPresent(Bool.self, forKey: "can_change_password")
      self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
      self.email = try values.decode(String.self, forKey: "email")
      self.isInvitePending = try values.decodeIfPresent(Bool.self, forKey: "invite_pending")
      self.name = try values.decodeIfPresent(String.self, forKey: "name")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encodeIfPresent(id, forKey: "id")
      try values.encodeIfPresent(avatarURL, forKey: "avatar_url")
      try values.encodeIfPresent(canChangePassword, forKey: "can_change_password")
      try values.encodeIfPresent(displayName, forKey: "display_name")
      try values.encode(email, forKey: "email")
      try values.encodeIfPresent(isInvitePending, forKey: "invite_pending")
      try values.encodeIfPresent(name, forKey: "name")
    }
  }

  public init(id: UUID, name: String, displayName: String? = nil, origin: Origin, isPublic: Bool, isShared: Bool? = nil, totalAppsCount: Double? = nil, totalUserCount: Double? = nil, notifiedUserCount: Double? = nil, groupType: GroupType? = nil, users: [User]? = nil) {
    self.id = id
    self.name = name
    self.displayName = displayName
    self.origin = origin
    self.isPublic = isPublic
    self.isShared = isShared
    self.totalAppsCount = totalAppsCount
    self.totalUserCount = totalUserCount
    self.notifiedUserCount = notifiedUserCount
    self.groupType = groupType
    self.users = users
  }

  public init(from decoder: Decoder) throws {
    let values = try decoder.container(keyedBy: StringCodingKey.self)
    self.id = try values.decode(UUID.self, forKey: "id")
    self.name = try values.decode(String.self, forKey: "name")
    self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
    self.origin = try values.decode(Origin.self, forKey: "origin")
    self.isPublic = try values.decode(Bool.self, forKey: "is_public")
    self.isShared = try values.decodeIfPresent(Bool.self, forKey: "is_shared")
    self.totalAppsCount = try values.decodeIfPresent(Double.self, forKey: "total_apps_count")
    self.totalUserCount = try values.decodeIfPresent(Double.self, forKey: "total_user_count")
    self.notifiedUserCount = try values.decodeIfPresent(Double.self, forKey: "notified_user_count")
    self.groupType = try values.decodeIfPresent(GroupType.self, forKey: "group_type")
    self.users = try values.decodeIfPresent([User].self, forKey: "users")
  }

  public func encode(to encoder: Encoder) throws {
    var values = encoder.container(keyedBy: StringCodingKey.self)
    try values.encode(id, forKey: "id")
    try values.encode(name, forKey: "name")
    try values.encodeIfPresent(displayName, forKey: "display_name")
    try values.encode(origin, forKey: "origin")
    try values.encode(isPublic, forKey: "is_public")
    try values.encodeIfPresent(isShared, forKey: "is_shared")
    try values.encodeIfPresent(totalAppsCount, forKey: "total_apps_count")
    try values.encodeIfPresent(totalUserCount, forKey: "total_user_count")
    try values.encodeIfPresent(notifiedUserCount, forKey: "notified_user_count")
    try values.encodeIfPresent(groupType, forKey: "group_type")
    try values.encodeIfPresent(users, forKey: "users")
  }
}
