// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Selection of a billing plan for one or more services
public struct BillingPlansSelection: Codable {
  /// Selection of a billing plan
  public var buildService: BuildService?
  /// Selection of a billing plan
  public var testService: TestService?

  /// Selection of a billing plan
  public struct BuildService: Codable {
    /// Number of instances of the billing plan.
    public var count: Int?
    /// Billing Plan
    public var plan: Plan?

    /// Billing Plan
    public struct Plan: Codable, Identifiable {
      /// The Billing Plan ID
      public var id: String?
      /// Version of the Billing Plan schema
      public var version: String?
      /// Price of the Billing Plan
      public var price: Double?
      /// Service that receives payments for this billing plan.
      public var paymentSource: PaymentSource?
      /// Name of the service that the plan applies to.
      public var service: Service?
      /// A collection of named numeric values
      public var limits: [String: Double]?
      /// Collection of attribute values.
      public var attributes: [String: [String: AnyJSON]]?
      public var parentID: String?

      /// Service that receives payments for this billing plan.
      public enum PaymentSource: String, Codable, CaseIterable {
        case `none` = "None"
        case appCenter = "AppCenter"
        case gitHub = "GitHub"
        case xtc = "Xtc"
      }

      /// Name of the service that the plan applies to.
      public enum Service: String, Codable, CaseIterable {
        case build = "Build"
        case test = "Test"
      }

      public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
        self.id = id
        self.version = version
        self.price = price
        self.paymentSource = paymentSource
        self.service = service
        self.limits = limits
        self.attributes = attributes
        self.parentID = parentID
      }

      public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.version = try values.decodeIfPresent(String.self, forKey: "version")
        self.price = try values.decodeIfPresent(Double.self, forKey: "price")
        self.paymentSource = try values.decodeIfPresent(PaymentSource.self, forKey: "paymentSource")
        self.service = try values.decodeIfPresent(Service.self, forKey: "service")
        self.limits = try values.decodeIfPresent([String: Double].self, forKey: "limits")
        self.attributes = try values.decodeIfPresent([String: [String: AnyJSON]].self, forKey: "attributes")
        self.parentID = try values.decodeIfPresent(String.self, forKey: "parentId")
      }

      public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(version, forKey: "version")
        try values.encodeIfPresent(price, forKey: "price")
        try values.encodeIfPresent(paymentSource, forKey: "paymentSource")
        try values.encodeIfPresent(service, forKey: "service")
        try values.encodeIfPresent(limits, forKey: "limits")
        try values.encodeIfPresent(attributes, forKey: "attributes")
        try values.encodeIfPresent(parentID, forKey: "parentId")
      }
    }

    public init(count: Int? = nil, plan: Plan? = nil) {
      self.count = count
      self.plan = plan
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.count = try values.decodeIfPresent(Int.self, forKey: "count")
      self.plan = try values.decodeIfPresent(Plan.self, forKey: "plan")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encodeIfPresent(count, forKey: "count")
      try values.encodeIfPresent(plan, forKey: "plan")
    }
  }

  /// Selection of a billing plan
  public struct TestService: Codable {
    /// Number of instances of the billing plan.
    public var count: Int?
    /// Billing Plan
    public var plan: Plan?

    /// Billing Plan
    public struct Plan: Codable, Identifiable {
      /// The Billing Plan ID
      public var id: String?
      /// Version of the Billing Plan schema
      public var version: String?
      /// Price of the Billing Plan
      public var price: Double?
      /// Service that receives payments for this billing plan.
      public var paymentSource: PaymentSource?
      /// Name of the service that the plan applies to.
      public var service: Service?
      /// A collection of named numeric values
      public var limits: [String: Double]?
      /// Collection of attribute values.
      public var attributes: [String: [String: AnyJSON]]?
      public var parentID: String?

      /// Service that receives payments for this billing plan.
      public enum PaymentSource: String, Codable, CaseIterable {
        case `none` = "None"
        case appCenter = "AppCenter"
        case gitHub = "GitHub"
        case xtc = "Xtc"
      }

      /// Name of the service that the plan applies to.
      public enum Service: String, Codable, CaseIterable {
        case build = "Build"
        case test = "Test"
      }

      public init(id: String? = nil, version: String? = nil, price: Double? = nil, paymentSource: PaymentSource? = nil, service: Service? = nil, limits: [String: Double]? = nil, attributes: [String: [String: AnyJSON]]? = nil, parentID: String? = nil) {
        self.id = id
        self.version = version
        self.price = price
        self.paymentSource = paymentSource
        self.service = service
        self.limits = limits
        self.attributes = attributes
        self.parentID = parentID
      }

      public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.version = try values.decodeIfPresent(String.self, forKey: "version")
        self.price = try values.decodeIfPresent(Double.self, forKey: "price")
        self.paymentSource = try values.decodeIfPresent(PaymentSource.self, forKey: "paymentSource")
        self.service = try values.decodeIfPresent(Service.self, forKey: "service")
        self.limits = try values.decodeIfPresent([String: Double].self, forKey: "limits")
        self.attributes = try values.decodeIfPresent([String: [String: AnyJSON]].self, forKey: "attributes")
        self.parentID = try values.decodeIfPresent(String.self, forKey: "parentId")
      }

      public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(id, forKey: "id")
        try values.encodeIfPresent(version, forKey: "version")
        try values.encodeIfPresent(price, forKey: "price")
        try values.encodeIfPresent(paymentSource, forKey: "paymentSource")
        try values.encodeIfPresent(service, forKey: "service")
        try values.encodeIfPresent(limits, forKey: "limits")
        try values.encodeIfPresent(attributes, forKey: "attributes")
        try values.encodeIfPresent(parentID, forKey: "parentId")
      }
    }

    public init(count: Int? = nil, plan: Plan? = nil) {
      self.count = count
      self.plan = plan
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.count = try values.decodeIfPresent(Int.self, forKey: "count")
      self.plan = try values.decodeIfPresent(Plan.self, forKey: "plan")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encodeIfPresent(count, forKey: "count")
      try values.encodeIfPresent(plan, forKey: "plan")
    }
  }

  public init(buildService: BuildService? = nil, testService: TestService? = nil) {
    self.buildService = buildService
    self.testService = testService
  }

  public init(from decoder: Decoder) throws {
    let values = try decoder.container(keyedBy: StringCodingKey.self)
    self.buildService = try values.decodeIfPresent(BuildService.self, forKey: "buildService")
    self.testService = try values.decodeIfPresent(TestService.self, forKey: "testService")
  }

  public func encode(to encoder: Encoder) throws {
    var values = encoder.container(keyedBy: StringCodingKey.self)
    try values.encodeIfPresent(buildService, forKey: "buildService")
    try values.encodeIfPresent(testService, forKey: "testService")
  }
}
