// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// A single symbol upload entity
public struct SymbolUploadsItem: Codable {
  /// The id for the current symbol upload
  public var symbolUploadID: String
  /// The application that this symbol upload belongs to
  public var appID: String
  /// User information of the one who intitiated the symbol upload
  public var user: User?
  /// The current status for the symbol upload
  public var status: Status
  /// The type of the symbol for the current symbol upload
  public var symbolType: SymbolType
  /// The symbols found in the upload. This may be empty until the status is indexed
  public var symbolsUploaded: [SymbolsUploadedItem]?
  /// The origin of the symbol upload
  public var origin: Origin?
  /// The file name for the symbol upload
  public var fileName: String?
  /// The size of the file in Mebibytes. This may be 0 until the status is indexed
  public var fileSize: Double?
  /// When the symbol upload was committed, or last transaction time if not committed
  public var timestamp: Date?

  /// User information of the one who intitiated the symbol upload
  public struct User: Codable {
    /// The email of the user
    public var email: String?
    /// The full name of the user. Might for example be first and last name
    public var displayName: String?

    public init(email: String? = nil, displayName: String? = nil) {
      self.email = email
      self.displayName = displayName
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.email = try values.decodeIfPresent(String.self, forKey: "email")
      self.displayName = try values.decodeIfPresent(String.self, forKey: "display_name")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encodeIfPresent(email, forKey: "email")
      try values.encodeIfPresent(displayName, forKey: "display_name")
    }
  }

  /// The current status for the symbol upload
  public enum Status: String, Codable, CaseIterable {
    case created
    case committed
    case aborted
    case processing
    case indexed
    case failed
  }

  /// The type of the symbol for the current symbol upload
  public enum SymbolType: String, Codable, CaseIterable {
    case apple = "Apple"
    case javaScript = "JavaScript"
    case breakpad = "Breakpad"
    case androidProguard = "AndroidProguard"
    case uwp = "UWP"
  }

  public struct SymbolsUploadedItem: Codable {
    /// The symbol id of the symbol binary
    public var symbolID: String
    /// The platform the symbol is associated with
    public var platform: String

    public init(symbolID: String, platform: String) {
      self.symbolID = symbolID
      self.platform = platform
    }

    public init(from decoder: Decoder) throws {
      let values = try decoder.container(keyedBy: StringCodingKey.self)
      self.symbolID = try values.decode(String.self, forKey: "symbol_id")
      self.platform = try values.decode(String.self, forKey: "platform")
    }

    public func encode(to encoder: Encoder) throws {
      var values = encoder.container(keyedBy: StringCodingKey.self)
      try values.encode(symbolID, forKey: "symbol_id")
      try values.encode(platform, forKey: "platform")
    }
  }

  /// The origin of the symbol upload
  public enum Origin: String, Codable, CaseIterable {
    case user = "User"
    case system = "System"
  }

  public init(symbolUploadID: String, appID: String, user: User? = nil, status: Status, symbolType: SymbolType, symbolsUploaded: [SymbolsUploadedItem]? = nil, origin: Origin? = nil, fileName: String? = nil, fileSize: Double? = nil, timestamp: Date? = nil) {
    self.symbolUploadID = symbolUploadID
    self.appID = appID
    self.user = user
    self.status = status
    self.symbolType = symbolType
    self.symbolsUploaded = symbolsUploaded
    self.origin = origin
    self.fileName = fileName
    self.fileSize = fileSize
    self.timestamp = timestamp
  }

  public init(from decoder: Decoder) throws {
    let values = try decoder.container(keyedBy: StringCodingKey.self)
    self.symbolUploadID = try values.decode(String.self, forKey: "symbol_upload_id")
    self.appID = try values.decode(String.self, forKey: "app_id")
    self.user = try values.decodeIfPresent(User.self, forKey: "user")
    self.status = try values.decode(Status.self, forKey: "status")
    self.symbolType = try values.decode(SymbolType.self, forKey: "symbol_type")
    self.symbolsUploaded = try values.decodeIfPresent([SymbolsUploadedItem].self, forKey: "symbols_uploaded")
    self.origin = try values.decodeIfPresent(Origin.self, forKey: "origin")
    self.fileName = try values.decodeIfPresent(String.self, forKey: "file_name")
    self.fileSize = try values.decodeIfPresent(Double.self, forKey: "file_size")
    self.timestamp = try values.decodeIfPresent(Date.self, forKey: "timestamp")
  }

  public func encode(to encoder: Encoder) throws {
    var values = encoder.container(keyedBy: StringCodingKey.self)
    try values.encode(symbolUploadID, forKey: "symbol_upload_id")
    try values.encode(appID, forKey: "app_id")
    try values.encodeIfPresent(user, forKey: "user")
    try values.encode(status, forKey: "status")
    try values.encode(symbolType, forKey: "symbol_type")
    try values.encodeIfPresent(symbolsUploaded, forKey: "symbols_uploaded")
    try values.encodeIfPresent(origin, forKey: "origin")
    try values.encodeIfPresent(fileName, forKey: "file_name")
    try values.encodeIfPresent(fileSize, forKey: "file_size")
    try values.encodeIfPresent(timestamp, forKey: "timestamp")
  }
}
