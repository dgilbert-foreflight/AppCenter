// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension API.Apps.WithOwnerName.WithAppName {
  public var deviceConfigurations: DeviceConfigurations {
    DeviceConfigurations(path: path + "/device_configurations")
  }

  public struct DeviceConfigurations {
    /// Path: `/v0.1/apps/{owner_name}/{app_name}/device_configurations`
    public let path: String

    /// Returns a list of available devices
    public func get(appUploadID: UUID? = nil) -> Request<[GetResponseItem]> {
      Request(method: "GET", url: path, query: makeGetQuery(appUploadID), id: "test_getDeviceConfigurations")
    }

    public struct GetResponseItem: Decodable, Identifiable {
      /// The name of the device model and OS version
      public var name: String?
      /// The unique id of the device configuration
      public var id: UUID?
      /// The tier
      public var tier: Double?
      public var image: Image?
      public var model: Model?
      public var os: String?
      public var osName: String?
      public var marketShare: Double?

      public struct Image: Decodable {
        public var full: String?
        public var thumb: String?

        public init(full: String? = nil, thumb: String? = nil) {
          self.full = full
          self.thumb = thumb
        }

        public init(from decoder: Decoder) throws {
          let values = try decoder.container(keyedBy: StringCodingKey.self)
          self.full = try values.decodeIfPresent(String.self, forKey: "full")
          self.thumb = try values.decodeIfPresent(String.self, forKey: "thumb")
        }
      }

      public struct Model: Decodable {
        public var name: String?
        public var manufacturer: String?
        public var model: String?
        public var platform: String?
        /// Physical device dimensions
        public var dimensions: Dimensions?
        /// Device screen resolution
        public var resolution: Resolution?
        public var releaseDate: String?
        public var formFactor: String?
        /// Physical device screen dimensions
        public var screenSize: ScreenSize?
        /// CPU data for device
        public var cpu: Cpu?
        /// Memory data for device
        public var memory: Memory?
        public var screenRotation: Double?
        public var deviceFrame: DeviceFrame?
        public var availabilityCount: Double?

        /// Physical device dimensions
        public struct Dimensions: Decodable {
          public var depth: [String: AnyJSON]?
          public var height: [String: AnyJSON]?
          public var width: [String: AnyJSON]?

          public init(depth: [String: AnyJSON]? = nil, height: [String: AnyJSON]? = nil, width: [String: AnyJSON]? = nil) {
            self.depth = depth
            self.height = height
            self.width = width
          }

          public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.depth = try values.decodeIfPresent([String: AnyJSON].self, forKey: "depth")
            self.height = try values.decodeIfPresent([String: AnyJSON].self, forKey: "height")
            self.width = try values.decodeIfPresent([String: AnyJSON].self, forKey: "width")
          }
        }

        /// Device screen resolution
        public struct Resolution: Decodable {
          public var height: String?
          public var width: String?
          public var ppi: String?

          public init(height: String? = nil, width: String? = nil, ppi: String? = nil) {
            self.height = height
            self.width = width
            self.ppi = ppi
          }

          public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.height = try values.decodeIfPresent(String.self, forKey: "height")
            self.width = try values.decodeIfPresent(String.self, forKey: "width")
            self.ppi = try values.decodeIfPresent(String.self, forKey: "ppi")
          }
        }

        /// Physical device screen dimensions
        public struct ScreenSize: Decodable {
          public var cm: String?
          public var `in`: String?

          public init(cm: String? = nil, `in`: String? = nil) {
            self.cm = cm
            self.in = `in`
          }

          public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.cm = try values.decodeIfPresent(String.self, forKey: "cm")
            self.in = try values.decodeIfPresent(String.self, forKey: "in")
          }
        }

        /// CPU data for device
        public struct Cpu: Decodable {
          public var frequency: String?
          public var core: String?
          public var text: String?

          public init(frequency: String? = nil, core: String? = nil, text: String? = nil) {
            self.frequency = frequency
            self.core = core
            self.text = text
          }

          public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.frequency = try values.decodeIfPresent(String.self, forKey: "frequency")
            self.core = try values.decodeIfPresent(String.self, forKey: "core")
            self.text = try values.decodeIfPresent(String.self, forKey: "text")
          }
        }

        /// Memory data for device
        public struct Memory: Decodable {
          public var formattedSize: String?

          public init(formattedSize: String? = nil) {
            self.formattedSize = formattedSize
          }

          public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.formattedSize = try values.decodeIfPresent(String.self, forKey: "formattedSize")
          }
        }

        public struct DeviceFrame: Decodable {
          public var grid: Grid?
          public var full: Full?

          public struct Grid: Decodable {
            public var width: Double?
            public var height: Double?
            public var frameURL: String?
            public var screen: [Double]?

            public init(width: Double? = nil, height: Double? = nil, frameURL: String? = nil, screen: [Double]? = nil) {
              self.width = width
              self.height = height
              self.frameURL = frameURL
              self.screen = screen
            }

            public init(from decoder: Decoder) throws {
              let values = try decoder.container(keyedBy: StringCodingKey.self)
              self.width = try values.decodeIfPresent(Double.self, forKey: "width")
              self.height = try values.decodeIfPresent(Double.self, forKey: "height")
              self.frameURL = try values.decodeIfPresent(String.self, forKey: "frameUrl")
              self.screen = try values.decodeIfPresent([Double].self, forKey: "screen")
            }
          }

          public struct Full: Decodable {
            public var width: Double?
            public var height: Double?
            public var frameURL: String?
            public var screen: [Double]?

            public init(width: Double? = nil, height: Double? = nil, frameURL: String? = nil, screen: [Double]? = nil) {
              self.width = width
              self.height = height
              self.frameURL = frameURL
              self.screen = screen
            }

            public init(from decoder: Decoder) throws {
              let values = try decoder.container(keyedBy: StringCodingKey.self)
              self.width = try values.decodeIfPresent(Double.self, forKey: "width")
              self.height = try values.decodeIfPresent(Double.self, forKey: "height")
              self.frameURL = try values.decodeIfPresent(String.self, forKey: "frameUrl")
              self.screen = try values.decodeIfPresent([Double].self, forKey: "screen")
            }
          }

          public init(grid: Grid? = nil, full: Full? = nil) {
            self.grid = grid
            self.full = full
          }

          public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.grid = try values.decodeIfPresent(Grid.self, forKey: "grid")
            self.full = try values.decodeIfPresent(Full.self, forKey: "full")
          }
        }

        public init(name: String? = nil, manufacturer: String? = nil, model: String? = nil, platform: String? = nil, dimensions: Dimensions? = nil, resolution: Resolution? = nil, releaseDate: String? = nil, formFactor: String? = nil, screenSize: ScreenSize? = nil, cpu: Cpu? = nil, memory: Memory? = nil, screenRotation: Double? = nil, deviceFrame: DeviceFrame? = nil, availabilityCount: Double? = nil) {
          self.name = name
          self.manufacturer = manufacturer
          self.model = model
          self.platform = platform
          self.dimensions = dimensions
          self.resolution = resolution
          self.releaseDate = releaseDate
          self.formFactor = formFactor
          self.screenSize = screenSize
          self.cpu = cpu
          self.memory = memory
          self.screenRotation = screenRotation
          self.deviceFrame = deviceFrame
          self.availabilityCount = availabilityCount
        }

        public init(from decoder: Decoder) throws {
          let values = try decoder.container(keyedBy: StringCodingKey.self)
          self.name = try values.decodeIfPresent(String.self, forKey: "name")
          self.manufacturer = try values.decodeIfPresent(String.self, forKey: "manufacturer")
          self.model = try values.decodeIfPresent(String.self, forKey: "model")
          self.platform = try values.decodeIfPresent(String.self, forKey: "platform")
          self.dimensions = try values.decodeIfPresent(Dimensions.self, forKey: "dimensions")
          self.resolution = try values.decodeIfPresent(Resolution.self, forKey: "resolution")
          self.releaseDate = try values.decodeIfPresent(String.self, forKey: "releaseDate")
          self.formFactor = try values.decodeIfPresent(String.self, forKey: "formFactor")
          self.screenSize = try values.decodeIfPresent(ScreenSize.self, forKey: "screenSize")
          self.cpu = try values.decodeIfPresent(Cpu.self, forKey: "cpu")
          self.memory = try values.decodeIfPresent(Memory.self, forKey: "memory")
          self.screenRotation = try values.decodeIfPresent(Double.self, forKey: "screenRotation")
          self.deviceFrame = try values.decodeIfPresent(DeviceFrame.self, forKey: "deviceFrame")
          self.availabilityCount = try values.decodeIfPresent(Double.self, forKey: "availabilityCount")
        }
      }

      public init(name: String? = nil, id: UUID? = nil, tier: Double? = nil, image: Image? = nil, model: Model? = nil, os: String? = nil, osName: String? = nil, marketShare: Double? = nil) {
        self.name = name
        self.id = id
        self.tier = tier
        self.image = image
        self.model = model
        self.os = os
        self.osName = osName
        self.marketShare = marketShare
      }

      public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.id = try values.decodeIfPresent(UUID.self, forKey: "id")
        self.tier = try values.decodeIfPresent(Double.self, forKey: "tier")
        self.image = try values.decodeIfPresent(Image.self, forKey: "image")
        self.model = try values.decodeIfPresent(Model.self, forKey: "model")
        self.os = try values.decodeIfPresent(String.self, forKey: "os")
        self.osName = try values.decodeIfPresent(String.self, forKey: "osName")
        self.marketShare = try values.decodeIfPresent(Double.self, forKey: "marketShare")
      }
    }

    private func makeGetQuery(_ appUploadID: UUID?) -> [(String, String?)] {
      let encoder = URLQueryEncoder()
      encoder.encode(appUploadID, forKey: "app_upload_id")
      return encoder.items
    }
  }
}
