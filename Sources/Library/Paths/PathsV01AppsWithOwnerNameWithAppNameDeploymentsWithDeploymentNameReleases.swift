// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension API.Apps.WithOwnerName.WithAppName.Deployments.WithDeploymentName {
  public var releases: Releases {
    Releases(path: path + "/releases")
  }

  public struct Releases {
    /// Path: `/v0.1/apps/{owner_name}/{app_name}/deployments/{deployment_name}/releases`
    public let path: String

    /// Gets the history of releases on a Deployment
    public var get: Request<[GetResponseItem]> {
      Request(method: "GET", url: path, id: "codePushDeploymentReleases_get")
    }

    public struct GetResponseItem: Decodable {
      public var targetBinaryRange: String?
      public var description: String?
      public var isDisabled: Bool?
      public var isMandatory: Bool?
      public var rollout: Int?
      public var label: String?
      public var packageHash: String?
      public var blobURL: String?
      public var diffPackageMap: [String: DiffPackageMapItem]?
      /// Set on 'Promote'
      public var originalDeployment: String?
      /// Set on 'Promote' and 'Rollback'
      public var originalLabel: String?
      public var releasedBy: String?
      /// The release method is unknown if unspecified
      public var releaseMethod: ReleaseMethod?
      public var size: Double?
      public var uploadTime: Int?

      public struct DiffPackageMapItem: Decodable {
        public var size: Double
        public var url: String

        public init(size: Double, url: String) {
          self.size = size
          self.url = url
        }

        public init(from decoder: Decoder) throws {
          let values = try decoder.container(keyedBy: StringCodingKey.self)
          self.size = try values.decode(Double.self, forKey: "size")
          self.url = try values.decode(String.self, forKey: "url")
        }
      }

      /// The release method is unknown if unspecified
      public enum ReleaseMethod: String, Codable, CaseIterable {
        case upload = "Upload"
        case promote = "Promote"
        case rollback = "Rollback"
      }

      public init(targetBinaryRange: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, rollout: Int? = nil, label: String? = nil, packageHash: String? = nil, blobURL: String? = nil, diffPackageMap: [String: DiffPackageMapItem]? = nil, originalDeployment: String? = nil, originalLabel: String? = nil, releasedBy: String? = nil, releaseMethod: ReleaseMethod? = nil, size: Double? = nil, uploadTime: Int? = nil) {
        self.targetBinaryRange = targetBinaryRange
        self.description = description
        self.isDisabled = isDisabled
        self.isMandatory = isMandatory
        self.rollout = rollout
        self.label = label
        self.packageHash = packageHash
        self.blobURL = blobURL
        self.diffPackageMap = diffPackageMap
        self.originalDeployment = originalDeployment
        self.originalLabel = originalLabel
        self.releasedBy = releasedBy
        self.releaseMethod = releaseMethod
        self.size = size
        self.uploadTime = uploadTime
      }

      public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.targetBinaryRange = try values.decodeIfPresent(String.self, forKey: "target_binary_range")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.isDisabled = try values.decodeIfPresent(Bool.self, forKey: "is_disabled")
        self.isMandatory = try values.decodeIfPresent(Bool.self, forKey: "is_mandatory")
        self.rollout = try values.decodeIfPresent(Int.self, forKey: "rollout")
        self.label = try values.decodeIfPresent(String.self, forKey: "label")
        self.packageHash = try values.decodeIfPresent(String.self, forKey: "package_hash")
        self.blobURL = try values.decodeIfPresent(String.self, forKey: "blob_url")
        self.diffPackageMap = try values.decodeIfPresent([String: DiffPackageMapItem].self, forKey: "diff_package_map")
        self.originalDeployment = try values.decodeIfPresent(String.self, forKey: "original_deployment")
        self.originalLabel = try values.decodeIfPresent(String.self, forKey: "original_label")
        self.releasedBy = try values.decodeIfPresent(String.self, forKey: "released_by")
        self.releaseMethod = try values.decodeIfPresent(ReleaseMethod.self, forKey: "release_method")
        self.size = try values.decodeIfPresent(Double.self, forKey: "size")
        self.uploadTime = try values.decodeIfPresent(Int.self, forKey: "upload_time")
      }
    }

    /// Create a new CodePush release for the specified deployment
    public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
      Request(method: "POST", url: path, body: body, id: "codePushDeploymentReleases_create")
    }

    public struct PostRequest: Encodable {
      /// The upload metadata from the release initialization step.
      public var releaseUpload: ReleaseUpload
      /// The binary version of the application
      public var targetBinaryVersion: String
      /// This specifies which deployment you want to release the update to. Default is Staging.
      public var deploymentName: String?
      /// This provides an optional "change log" for the deployment.
      public var description: String?
      /// This specifies whether an update should be downloadable by end users or not.
      public var isDisabled: Bool?
      /// This specifies whether the update should be considered mandatory or not (e.g. it includes a critical security fix).
      public var isMandatory: Bool?
      /// This specifies that if the update is identical to the latest release on the deployment, the CLI should generate a warning instead of an error.
      public var isNoDuplicateReleaseError: Bool?
      /// This specifies the percentage of users (as an integer between 1 and 100) that should be eligible to receive this update.
      public var rollout: Int?

      /// The upload metadata from the release initialization step.
      public struct ReleaseUpload: Encodable, Identifiable {
        /// The ID for the newly created upload. It is going to be required later in the process.
        public var id: UUID
        /// The URL domain used to upload the release.
        public var uploadDomain: String
        /// The URL encoded token used for upload permissions.
        public var token: String

        public init(id: UUID, uploadDomain: String, token: String) {
          self.id = id
          self.uploadDomain = uploadDomain
          self.token = token
        }

        public func encode(to encoder: Encoder) throws {
          var values = encoder.container(keyedBy: StringCodingKey.self)
          try values.encode(id, forKey: "id")
          try values.encode(uploadDomain, forKey: "upload_domain")
          try values.encode(token, forKey: "token")
        }
      }

      public init(releaseUpload: ReleaseUpload, targetBinaryVersion: String, deploymentName: String? = nil, description: String? = nil, isDisabled: Bool? = nil, isMandatory: Bool? = nil, isNoDuplicateReleaseError: Bool? = nil, rollout: Int? = nil) {
        self.releaseUpload = releaseUpload
        self.targetBinaryVersion = targetBinaryVersion
        self.deploymentName = deploymentName
        self.description = description
        self.isDisabled = isDisabled
        self.isMandatory = isMandatory
        self.isNoDuplicateReleaseError = isNoDuplicateReleaseError
        self.rollout = rollout
      }

      public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(releaseUpload, forKey: "release_upload")
        try values.encode(targetBinaryVersion, forKey: "target_binary_version")
        try values.encodeIfPresent(deploymentName, forKey: "deployment_name")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encodeIfPresent(isDisabled, forKey: "disabled")
        try values.encodeIfPresent(isMandatory, forKey: "mandatory")
        try values.encodeIfPresent(isNoDuplicateReleaseError, forKey: "no_duplicate_release_error")
        try values.encodeIfPresent(rollout, forKey: "rollout")
      }
    }

    /// Clears a Deployment of releases
    public var delete: Request<Void> {
      Request(method: "DELETE", url: path, id: "codePushDeploymentReleases_delete")
    }
  }
}
