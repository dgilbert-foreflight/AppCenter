// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension API.Apps.WithOwnerName.WithAppName.CrashGroups {
  public func crashGroupID(_ crashGroupID: String) -> WithCrashGroupID {
    WithCrashGroupID(path: "\(path)/\(crashGroupID)")
  }

  public struct WithCrashGroupID {
    /// Path: `/v0.1/apps/{owner_name}/{app_name}/crash_groups/{crash_group_id}`
    public let path: String

    /// Gets a specific group.
    @available(*, deprecated, message: "Deprecated")
    public var get: Request<GetResponse> {
      Request(method: "GET", url: path, id: "crashGroups_get")
    }

    public struct GetResponse: Decodable {
      public var crashGroupID: String
      public var newCrashGroupID: String
      public var displayID: String
      public var appVersion: String
      public var build: String
      public var status: Status
      public var count: Int
      public var impactedUsers: Int?
      public var firstOccurrence: Date
      public var lastOccurrence: Date
      public var exception: String?
      public var crashReason: String
      /// Frame belonging to the reason of the crash
      public var reasonFrame: ReasonFrame?
      /// Crash or handled exception
      public var isFatal: Bool
      public var annotation: String

      public enum Status: String, Codable, CaseIterable {
        case `open`
        case closed
        case ignored
      }

      /// Frame belonging to the reason of the crash
      public struct ReasonFrame: Decodable {
        /// Name of the class
        public var className: String?
        /// Name of the method
        public var method: String?
        /// Is a class method
        public var isClassMethod: Bool?
        /// Name of the file
        public var file: String?
        /// Line number
        public var line: Int?
        /// This line isn't from any framework
        public var isAppCode: Bool?
        /// Name of the framework
        public var frameworkName: String?
        /// Formatted frame string
        public var codeFormatted: String?
        /// Unformatted Frame string
        public var codeRaw: String?
        /// Programming language of the frame
        public var language: Language?
        /// Parameters of the frames method
        public var methodParams: String?
        /// Exception type.
        public var exceptionType: String?
        /// OS exception type. (aka. SIGNAL)
        public var osExceptionType: String?

        /// Programming language of the frame
        public enum Language: String, Codable, CaseIterable {
          case javaScript = "JavaScript"
          case cSharp = "CSharp"
          case objectiveC = "Objective-C"
          case objectiveCpp = "Objective-Cpp"
          case cpp = "Cpp"
          case c = "C"
          case swift = "Swift"
          case java = "Java"
          case unknown = "Unknown"
        }

        public init(className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool? = nil, frameworkName: String? = nil, codeFormatted: String? = nil, codeRaw: String? = nil, language: Language? = nil, methodParams: String? = nil, exceptionType: String? = nil, osExceptionType: String? = nil) {
          self.className = className
          self.method = method
          self.isClassMethod = isClassMethod
          self.file = file
          self.line = line
          self.isAppCode = isAppCode
          self.frameworkName = frameworkName
          self.codeFormatted = codeFormatted
          self.codeRaw = codeRaw
          self.language = language
          self.methodParams = methodParams
          self.exceptionType = exceptionType
          self.osExceptionType = osExceptionType
        }

        public init(from decoder: Decoder) throws {
          let values = try decoder.container(keyedBy: StringCodingKey.self)
          self.className = try values.decodeIfPresent(String.self, forKey: "class_name")
          self.method = try values.decodeIfPresent(String.self, forKey: "method")
          self.isClassMethod = try values.decodeIfPresent(Bool.self, forKey: "class_method")
          self.file = try values.decodeIfPresent(String.self, forKey: "file")
          self.line = try values.decodeIfPresent(Int.self, forKey: "line")
          self.isAppCode = try values.decodeIfPresent(Bool.self, forKey: "app_code")
          self.frameworkName = try values.decodeIfPresent(String.self, forKey: "framework_name")
          self.codeFormatted = try values.decodeIfPresent(String.self, forKey: "code_formatted")
          self.codeRaw = try values.decodeIfPresent(String.self, forKey: "code_raw")
          self.language = try values.decodeIfPresent(Language.self, forKey: "language")
          self.methodParams = try values.decodeIfPresent(String.self, forKey: "method_params")
          self.exceptionType = try values.decodeIfPresent(String.self, forKey: "exception_type")
          self.osExceptionType = try values.decodeIfPresent(String.self, forKey: "os_exception_type")
        }
      }

      public init(crashGroupID: String, newCrashGroupID: String, displayID: String, appVersion: String, build: String, status: Status, count: Int, impactedUsers: Int? = nil, firstOccurrence: Date, lastOccurrence: Date, exception: String? = nil, crashReason: String, reasonFrame: ReasonFrame? = nil, isFatal: Bool, annotation: String) {
        self.crashGroupID = crashGroupID
        self.newCrashGroupID = newCrashGroupID
        self.displayID = displayID
        self.appVersion = appVersion
        self.build = build
        self.status = status
        self.count = count
        self.impactedUsers = impactedUsers
        self.firstOccurrence = firstOccurrence
        self.lastOccurrence = lastOccurrence
        self.exception = exception
        self.crashReason = crashReason
        self.reasonFrame = reasonFrame
        self.isFatal = isFatal
        self.annotation = annotation
      }

      public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.crashGroupID = try values.decode(String.self, forKey: "crash_group_id")
        self.newCrashGroupID = try values.decode(String.self, forKey: "new_crash_group_id")
        self.displayID = try values.decode(String.self, forKey: "display_id")
        self.appVersion = try values.decode(String.self, forKey: "app_version")
        self.build = try values.decode(String.self, forKey: "build")
        self.status = try values.decode(Status.self, forKey: "status")
        self.count = try values.decode(Int.self, forKey: "count")
        self.impactedUsers = try values.decodeIfPresent(Int.self, forKey: "impacted_users")
        self.firstOccurrence = try values.decode(Date.self, forKey: "first_occurrence")
        self.lastOccurrence = try values.decode(Date.self, forKey: "last_occurrence")
        self.exception = try values.decodeIfPresent(String.self, forKey: "exception")
        self.crashReason = try values.decode(String.self, forKey: "crash_reason")
        self.reasonFrame = try values.decodeIfPresent(ReasonFrame.self, forKey: "reason_frame")
        self.isFatal = try values.decode(Bool.self, forKey: "fatal")
        self.annotation = try values.decode(String.self, forKey: "annotation")
      }
    }

    /// Updates a group.
    @available(*, deprecated, message: "Deprecated")
    public func patch(_ body: PatchRequest) -> Request<PatchResponse> {
      Request(method: "PATCH", url: path, body: body, id: "crashGroups_update")
    }

    public struct PatchResponse: Decodable {
      public var crashGroupID: String
      public var newCrashGroupID: String
      public var displayID: String
      public var appVersion: String
      public var build: String
      public var status: Status
      public var count: Int
      public var impactedUsers: Int?
      public var firstOccurrence: Date
      public var lastOccurrence: Date
      public var exception: String?
      public var crashReason: String
      /// Frame belonging to the reason of the crash
      public var reasonFrame: ReasonFrame?
      /// Crash or handled exception
      public var isFatal: Bool
      public var annotation: String

      public enum Status: String, Codable, CaseIterable {
        case `open`
        case closed
        case ignored
      }

      /// Frame belonging to the reason of the crash
      public struct ReasonFrame: Decodable {
        /// Name of the class
        public var className: String?
        /// Name of the method
        public var method: String?
        /// Is a class method
        public var isClassMethod: Bool?
        /// Name of the file
        public var file: String?
        /// Line number
        public var line: Int?
        /// This line isn't from any framework
        public var isAppCode: Bool?
        /// Name of the framework
        public var frameworkName: String?
        /// Formatted frame string
        public var codeFormatted: String?
        /// Unformatted Frame string
        public var codeRaw: String?
        /// Programming language of the frame
        public var language: Language?
        /// Parameters of the frames method
        public var methodParams: String?
        /// Exception type.
        public var exceptionType: String?
        /// OS exception type. (aka. SIGNAL)
        public var osExceptionType: String?

        /// Programming language of the frame
        public enum Language: String, Codable, CaseIterable {
          case javaScript = "JavaScript"
          case cSharp = "CSharp"
          case objectiveC = "Objective-C"
          case objectiveCpp = "Objective-Cpp"
          case cpp = "Cpp"
          case c = "C"
          case swift = "Swift"
          case java = "Java"
          case unknown = "Unknown"
        }

        public init(className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool? = nil, frameworkName: String? = nil, codeFormatted: String? = nil, codeRaw: String? = nil, language: Language? = nil, methodParams: String? = nil, exceptionType: String? = nil, osExceptionType: String? = nil) {
          self.className = className
          self.method = method
          self.isClassMethod = isClassMethod
          self.file = file
          self.line = line
          self.isAppCode = isAppCode
          self.frameworkName = frameworkName
          self.codeFormatted = codeFormatted
          self.codeRaw = codeRaw
          self.language = language
          self.methodParams = methodParams
          self.exceptionType = exceptionType
          self.osExceptionType = osExceptionType
        }

        public init(from decoder: Decoder) throws {
          let values = try decoder.container(keyedBy: StringCodingKey.self)
          self.className = try values.decodeIfPresent(String.self, forKey: "class_name")
          self.method = try values.decodeIfPresent(String.self, forKey: "method")
          self.isClassMethod = try values.decodeIfPresent(Bool.self, forKey: "class_method")
          self.file = try values.decodeIfPresent(String.self, forKey: "file")
          self.line = try values.decodeIfPresent(Int.self, forKey: "line")
          self.isAppCode = try values.decodeIfPresent(Bool.self, forKey: "app_code")
          self.frameworkName = try values.decodeIfPresent(String.self, forKey: "framework_name")
          self.codeFormatted = try values.decodeIfPresent(String.self, forKey: "code_formatted")
          self.codeRaw = try values.decodeIfPresent(String.self, forKey: "code_raw")
          self.language = try values.decodeIfPresent(Language.self, forKey: "language")
          self.methodParams = try values.decodeIfPresent(String.self, forKey: "method_params")
          self.exceptionType = try values.decodeIfPresent(String.self, forKey: "exception_type")
          self.osExceptionType = try values.decodeIfPresent(String.self, forKey: "os_exception_type")
        }
      }

      public init(crashGroupID: String, newCrashGroupID: String, displayID: String, appVersion: String, build: String, status: Status, count: Int, impactedUsers: Int? = nil, firstOccurrence: Date, lastOccurrence: Date, exception: String? = nil, crashReason: String, reasonFrame: ReasonFrame? = nil, isFatal: Bool, annotation: String) {
        self.crashGroupID = crashGroupID
        self.newCrashGroupID = newCrashGroupID
        self.displayID = displayID
        self.appVersion = appVersion
        self.build = build
        self.status = status
        self.count = count
        self.impactedUsers = impactedUsers
        self.firstOccurrence = firstOccurrence
        self.lastOccurrence = lastOccurrence
        self.exception = exception
        self.crashReason = crashReason
        self.reasonFrame = reasonFrame
        self.isFatal = isFatal
        self.annotation = annotation
      }

      public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.crashGroupID = try values.decode(String.self, forKey: "crash_group_id")
        self.newCrashGroupID = try values.decode(String.self, forKey: "new_crash_group_id")
        self.displayID = try values.decode(String.self, forKey: "display_id")
        self.appVersion = try values.decode(String.self, forKey: "app_version")
        self.build = try values.decode(String.self, forKey: "build")
        self.status = try values.decode(Status.self, forKey: "status")
        self.count = try values.decode(Int.self, forKey: "count")
        self.impactedUsers = try values.decodeIfPresent(Int.self, forKey: "impacted_users")
        self.firstOccurrence = try values.decode(Date.self, forKey: "first_occurrence")
        self.lastOccurrence = try values.decode(Date.self, forKey: "last_occurrence")
        self.exception = try values.decodeIfPresent(String.self, forKey: "exception")
        self.crashReason = try values.decode(String.self, forKey: "crash_reason")
        self.reasonFrame = try values.decodeIfPresent(ReasonFrame.self, forKey: "reason_frame")
        self.isFatal = try values.decode(Bool.self, forKey: "fatal")
        self.annotation = try values.decode(String.self, forKey: "annotation")
      }
    }

    public struct PatchRequest: Encodable {
      public var status: Status?
      public var annotation: String?

      public enum Status: String, Codable, CaseIterable {
        case `open`
        case closed
        case ignored
      }

      public init(status: Status? = nil, annotation: String? = nil) {
        self.status = status
        self.annotation = annotation
      }

      public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(status, forKey: "status")
        try values.encodeIfPresent(annotation, forKey: "annotation")
      }
    }
  }
}
