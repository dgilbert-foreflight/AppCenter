// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension API.Apps.WithOwnerName.WithAppName.TestRuns.WithTestRunID {
  public var stop: Stop {
    Stop(path: path + "/stop")
  }

  public struct Stop {
    /// Path: `/v0.1/apps/{owner_name}/{app_name}/test_runs/{test_run_id}/stop`
    public let path: String

    /// Stop a test run execution
    public var put: Request<PutResponse> {
      Request(method: "PUT", url: path, id: "test_stopTestRun")
    }

    /// Test Run
    ///
    /// Summary single test run on Xamarin Test Cloud
    public struct PutResponse: Decodable, Identifiable {
      /// The unique id of the test upload
      public var id: UUID?
      /// The date and time the test was uploaded
      public var date: String?
      /// The compiled version of the app binary
      public var appVersion: String?
      /// The name of the test series with which this test upload is associated
      public var testSeries: String?
      /// The device platform targeted by the test. Possible values are 'ios' or 'android'
      public var platform: String?
      /// The current status of the test run, in relation to the various phases
      public var runStatus: String?
      /// The passed/failed state
      public var resultStatus: String?
      /// Deprecated. Use runStatus instead.
      public var state: String?
      /// Deprecated. Use resultStatus instead.
      public var status: String?
      /// Human readable explanation of the current test status
      public var description: String?
      /// Test Run Statistics
      ///
      /// Summary single test run on Xamarin Test Cloud
      public var stats: Stats?
      /// The name of the test framework used to run this test
      public var testType: String?

      /// Test Run Statistics
      ///
      /// Summary single test run on Xamarin Test Cloud
      public struct Stats: Decodable {
        /// Number of devices running the test
        public var devices: Double?
        /// Number of finished devices
        public var devicesFinished: Double?
        /// Number of failed devices
        public var devicesFailed: Double?
        /// Number of tests in total
        public var total: Double?
        /// Number of passed tests
        public var passed: Double?
        /// Number of failed tests
        public var failed: Double?
        /// Number of skipped tests
        public var skipped: Double?
        /// The max amount of MB used during the test run
        public var peakMemory: Double?
        /// The number of minutes of device time the test has been runnign
        public var totalDeviceMinutes: Double?

        public init(devices: Double? = nil, devicesFinished: Double? = nil, devicesFailed: Double? = nil, total: Double? = nil, passed: Double? = nil, failed: Double? = nil, skipped: Double? = nil, peakMemory: Double? = nil, totalDeviceMinutes: Double? = nil) {
          self.devices = devices
          self.devicesFinished = devicesFinished
          self.devicesFailed = devicesFailed
          self.total = total
          self.passed = passed
          self.failed = failed
          self.skipped = skipped
          self.peakMemory = peakMemory
          self.totalDeviceMinutes = totalDeviceMinutes
        }

        public init(from decoder: Decoder) throws {
          let values = try decoder.container(keyedBy: StringCodingKey.self)
          self.devices = try values.decodeIfPresent(Double.self, forKey: "devices")
          self.devicesFinished = try values.decodeIfPresent(Double.self, forKey: "devicesFinished")
          self.devicesFailed = try values.decodeIfPresent(Double.self, forKey: "devicesFailed")
          self.total = try values.decodeIfPresent(Double.self, forKey: "total")
          self.passed = try values.decodeIfPresent(Double.self, forKey: "passed")
          self.failed = try values.decodeIfPresent(Double.self, forKey: "failed")
          self.skipped = try values.decodeIfPresent(Double.self, forKey: "skipped")
          self.peakMemory = try values.decodeIfPresent(Double.self, forKey: "peakMemory")
          self.totalDeviceMinutes = try values.decodeIfPresent(Double.self, forKey: "totalDeviceMinutes")
        }
      }

      public init(id: UUID? = nil, date: String? = nil, appVersion: String? = nil, testSeries: String? = nil, platform: String? = nil, runStatus: String? = nil, resultStatus: String? = nil, state: String? = nil, status: String? = nil, description: String? = nil, stats: Stats? = nil, testType: String? = nil) {
        self.id = id
        self.date = date
        self.appVersion = appVersion
        self.testSeries = testSeries
        self.platform = platform
        self.runStatus = runStatus
        self.resultStatus = resultStatus
        self.state = state
        self.status = status
        self.description = description
        self.stats = stats
        self.testType = testType
      }

      public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(UUID.self, forKey: "id")
        self.date = try values.decodeIfPresent(String.self, forKey: "date")
        self.appVersion = try values.decodeIfPresent(String.self, forKey: "appVersion")
        self.testSeries = try values.decodeIfPresent(String.self, forKey: "testSeries")
        self.platform = try values.decodeIfPresent(String.self, forKey: "platform")
        self.runStatus = try values.decodeIfPresent(String.self, forKey: "runStatus")
        self.resultStatus = try values.decodeIfPresent(String.self, forKey: "resultStatus")
        self.state = try values.decodeIfPresent(String.self, forKey: "state")
        self.status = try values.decodeIfPresent(String.self, forKey: "status")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.stats = try values.decodeIfPresent(Stats.self, forKey: "stats")
        self.testType = try values.decodeIfPresent(String.self, forKey: "testType")
      }
    }
  }
}
