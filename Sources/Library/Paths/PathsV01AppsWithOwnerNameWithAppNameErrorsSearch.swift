// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension API.Apps.WithOwnerName.WithAppName.Errors {
  public var search: Search {
    Search(path: path + "/search")
  }

  public struct Search {
    /// Path: `/v0.1/apps/{owner_name}/{app_name}/errors/search`
    public let path: String

    /// Errors list based on search parameters
    public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
      Request(method: "GET", url: path, query: parameters?.asQuery, id: "Errors_ErrorSearch")
    }

    public struct GetResponse: Decodable {
      public var hasMoreResults: Bool?
      public var errors: [Error]?

      public struct Error: Decodable {
        public var errorID: String?
        public var timestamp: Date?
        public var deviceName: String?
        public var osVersion: String?
        public var osType: String?
        public var country: String?
        public var language: String?
        public var userID: String?
        public var hasBreadcrumbs: Bool?
        public var hasAttachments: Bool?

        public init(errorID: String? = nil, timestamp: Date? = nil, deviceName: String? = nil, osVersion: String? = nil, osType: String? = nil, country: String? = nil, language: String? = nil, userID: String? = nil, hasBreadcrumbs: Bool? = nil, hasAttachments: Bool? = nil) {
          self.errorID = errorID
          self.timestamp = timestamp
          self.deviceName = deviceName
          self.osVersion = osVersion
          self.osType = osType
          self.country = country
          self.language = language
          self.userID = userID
          self.hasBreadcrumbs = hasBreadcrumbs
          self.hasAttachments = hasAttachments
        }

        public init(from decoder: Decoder) throws {
          let values = try decoder.container(keyedBy: StringCodingKey.self)
          self.errorID = try values.decodeIfPresent(String.self, forKey: "errorId")
          self.timestamp = try values.decodeIfPresent(Date.self, forKey: "timestamp")
          self.deviceName = try values.decodeIfPresent(String.self, forKey: "deviceName")
          self.osVersion = try values.decodeIfPresent(String.self, forKey: "osVersion")
          self.osType = try values.decodeIfPresent(String.self, forKey: "osType")
          self.country = try values.decodeIfPresent(String.self, forKey: "country")
          self.language = try values.decodeIfPresent(String.self, forKey: "language")
          self.userID = try values.decodeIfPresent(String.self, forKey: "userId")
          self.hasBreadcrumbs = try values.decodeIfPresent(Bool.self, forKey: "hasBreadcrumbs")
          self.hasAttachments = try values.decodeIfPresent(Bool.self, forKey: "hasAttachments")
        }
      }

      public init(hasMoreResults: Bool? = nil, errors: [Error]? = nil) {
        self.hasMoreResults = hasMoreResults
        self.errors = errors
      }

      public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.hasMoreResults = try values.decodeIfPresent(Bool.self, forKey: "hasMoreResults")
        self.errors = try values.decodeIfPresent([Error].self, forKey: "errors")
      }
    }

    public struct GetParameters {
      public var filter: String?
      public var q: String?
      public var order: Order?
      public var sort: Sort?
      public var top: Int64?
      public var skip: Int64?

      public enum Order: String, Codable, CaseIterable {
        case desc
        case asc
      }

      public enum Sort: String, Codable, CaseIterable {
        case timestamp
        case errorGroupID = "errorGroupId"
        case exceptionClassName
        case exceptionFile
        case exceptionLine
        case exceptionMessage
        case exceptionMethod
        case deviceName
        case osVersion
        case userID = "userId"
      }

      public init(filter: String? = nil, q: String? = nil, order: Order? = nil, sort: Sort? = nil, top: Int64? = nil, skip: Int64? = nil) {
        self.filter = filter
        self.q = q
        self.order = order
        self.sort = sort
        self.top = top
        self.skip = skip
      }

      public var asQuery: [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(filter, forKey: "filter")
        encoder.encode(q, forKey: "q")
        encoder.encode(order, forKey: "order")
        encoder.encode(sort, forKey: "sort")
        encoder.encode(top, forKey: "$top")
        encoder.encode(skip, forKey: "$skip")
        return encoder.items
      }
    }
  }
}
