// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension API.Apps.WithOwnerName.WithAppName {
  public var distributionStores: DistributionStores {
    DistributionStores(path: path + "/distribution_stores")
  }

  public struct DistributionStores {
    /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_stores`
    public let path: String

    /// Get all the store details from Storage store table for a particular application.
    public var get: Request<[GetResponseItem]> {
      Request(method: "GET", url: path, id: "stores_list")
    }

    /// ExternalStoreResponse
    public struct GetResponseItem: Decodable, Identifiable {
      /// Store id
      public var id: String?
      /// Store Name
      public var name: String?
      /// Store Type
      public var type: String?
      /// Store track
      public var track: Track?
      /// Store details for intune
      public var intuneDetails: IntuneDetails?
      /// Id for the shared service connection. In case of Apple / GooglePlay stores, this connection will be used to connect to the Apple / Google stores in App Center.
      public var serviceConnectionID: String?
      /// The ID of the principal that created the store.
      public var createdBy: String?
      /// The type of the principal that created the store.
      public var createdByPrincipalType: String?

      /// Store track
      public enum Track: String, Codable, CaseIterable {
        case production
        case alpha
        case beta
        case testflightInternal = "testflight-internal"
        case testflightExternal = "testflight-external"
      }

      /// Store details for intune
      public struct IntuneDetails: Decodable {
        public var targetAudience: TargetAudience?
        public var appCategory: AppCategory?

        public struct TargetAudience: Decodable, Identifiable {
          /// Display name for the target audience/group
          public var name: String?
          /// ID for the target audience/group.
          public var id: String?

          public init(name: String? = nil, id: String? = nil) {
            self.name = name
            self.id = id
          }

          public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
          }
        }

        public struct AppCategory: Decodable, Identifiable {
          /// Display name for the app category
          public var name: String?
          /// ID for the category.
          public var id: String?

          public init(name: String? = nil, id: String? = nil) {
            self.name = name
            self.id = id
          }

          public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.id = try values.decodeIfPresent(String.self, forKey: "id")
          }
        }

        public init(targetAudience: TargetAudience? = nil, appCategory: AppCategory? = nil) {
          self.targetAudience = targetAudience
          self.appCategory = appCategory
        }

        public init(from decoder: Decoder) throws {
          let values = try decoder.container(keyedBy: StringCodingKey.self)
          self.targetAudience = try values.decodeIfPresent(TargetAudience.self, forKey: "target_audience")
          self.appCategory = try values.decodeIfPresent(AppCategory.self, forKey: "app_category")
        }
      }

      public init(id: String? = nil, name: String? = nil, type: String? = nil, track: Track? = nil, intuneDetails: IntuneDetails? = nil, serviceConnectionID: String? = nil, createdBy: String? = nil, createdByPrincipalType: String? = nil) {
        self.id = id
        self.name = name
        self.type = type
        self.track = track
        self.intuneDetails = intuneDetails
        self.serviceConnectionID = serviceConnectionID
        self.createdBy = createdBy
        self.createdByPrincipalType = createdByPrincipalType
      }

      public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(String.self, forKey: "id")
        self.name = try values.decodeIfPresent(String.self, forKey: "name")
        self.type = try values.decodeIfPresent(String.self, forKey: "type")
        self.track = try values.decodeIfPresent(Track.self, forKey: "track")
        self.intuneDetails = try values.decodeIfPresent(IntuneDetails.self, forKey: "intune_details")
        self.serviceConnectionID = try values.decodeIfPresent(String.self, forKey: "service_connection_id")
        self.createdBy = try values.decodeIfPresent(String.self, forKey: "created_by")
        self.createdByPrincipalType = try values.decodeIfPresent(String.self, forKey: "created_by_principal_type")
      }
    }

    /// Create a new external store for the specified application.
    public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
      Request(method: "POST", url: path, body: body, id: "stores_create")
    }

    /// ExternalStoreRequest
    public struct PostRequest: Encodable {
      /// Store Type
      public var type: `Type`?
      /// Name of the store. In case of googleplay, and Apple store this is fixed to Production.
      public var name: String?
      /// Track of the store. Can be production, alpha & beta for googleplay. Can be production, testflight-internal & testflight-external for Apple Store.
      public var track: Track?
      public var intuneDetails: IntuneDetails?
      /// Id for the shared service connection. In case of Apple AppStore, this connection will be used to create and connect to the Apple AppStore in Mobile Center.
      public var serviceConnectionID: String?

      /// Store Type
      public enum `Type`: String, Codable, CaseIterable {
        case googleplay
        case apple
        case intune
      }

      /// Track of the store. Can be production, alpha & beta for googleplay. Can be production, testflight-internal & testflight-external for Apple Store.
      public enum Track: String, Codable, CaseIterable {
        case production
        case alpha
        case beta
        case testflightInternal = "testflight-internal"
        case testflightExternal = "testflight-external"
      }

      public struct IntuneDetails: Encodable {
        public var secretJSON: SecretJSON?
        public var targetAudience: TargetAudience?
        public var appCategory: AppCategory?
        /// Tenant id of the intune store
        public var tenantID: String?

        public struct SecretJSON: Encodable {
          /// The id token of user
          public var idToken: String?
          /// The refresh token for user
          public var refreshToken: String?
          /// The expiry of refresh token
          public var refreshTokenExpiry: String?

          public init(idToken: String? = nil, refreshToken: String? = nil, refreshTokenExpiry: String? = nil) {
            self.idToken = idToken
            self.refreshToken = refreshToken
            self.refreshTokenExpiry = refreshTokenExpiry
          }

          public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(idToken, forKey: "id_token")
            try values.encodeIfPresent(refreshToken, forKey: "refresh_token")
            try values.encodeIfPresent(refreshTokenExpiry, forKey: "refresh_token_expiry")
          }
        }

        public struct TargetAudience: Encodable {
          /// Display name for the target audience/group
          public var name: String?

          public init(name: String? = nil) {
            self.name = name
          }

          public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(name, forKey: "name")
          }
        }

        public struct AppCategory: Encodable {
          /// Display name for the app category
          public var name: String?

          public init(name: String? = nil) {
            self.name = name
          }

          public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(name, forKey: "name")
          }
        }

        public init(secretJSON: SecretJSON? = nil, targetAudience: TargetAudience? = nil, appCategory: AppCategory? = nil, tenantID: String? = nil) {
          self.secretJSON = secretJSON
          self.targetAudience = targetAudience
          self.appCategory = appCategory
          self.tenantID = tenantID
        }

        public func encode(to encoder: Encoder) throws {
          var values = encoder.container(keyedBy: StringCodingKey.self)
          try values.encodeIfPresent(secretJSON, forKey: "secret_json")
          try values.encodeIfPresent(targetAudience, forKey: "target_audience")
          try values.encodeIfPresent(appCategory, forKey: "app_category")
          try values.encodeIfPresent(tenantID, forKey: "tenant_id")
        }
      }

      public init(type: `Type`? = nil, name: String? = nil, track: Track? = nil, intuneDetails: IntuneDetails? = nil, serviceConnectionID: String? = nil) {
        self.type = type
        self.name = name
        self.track = track
        self.intuneDetails = intuneDetails
        self.serviceConnectionID = serviceConnectionID
      }

      public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(type, forKey: "type")
        try values.encodeIfPresent(name, forKey: "name")
        try values.encodeIfPresent(track, forKey: "track")
        try values.encodeIfPresent(intuneDetails, forKey: "intune_details")
        try values.encodeIfPresent(serviceConnectionID, forKey: "service_connection_id")
      }
    }
  }
}
