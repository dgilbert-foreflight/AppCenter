// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension API.Apps.WithOwnerName.WithAppName {
  public var crashGroups: CrashGroups {
    CrashGroups(path: path + "/crash_groups")
  }

  public struct CrashGroups {
    /// Path: `/v0.1/apps/{owner_name}/{app_name}/crash_groups`
    public let path: String

    /// Gets a list of crash groups and whether the list contains all available groups.
    @available(*, deprecated, message: "Deprecated")
    public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
      Request(method: "GET", url: path, query: parameters?.asQuery, id: "crashGroups_list")
    }

    public struct GetResponse: Decodable {
      public var isLimitedResultSet: Bool
      /// Cassandra request continuation token. The token is used for pagination.
      public var continuationToken: String?
      public var crashGroups: [CrashGroup]

      public struct CrashGroup: Decodable {
        public var crashGroupID: String
        public var newCrashGroupID: String
        public var displayID: String
        public var appVersion: String
        public var build: String
        public var status: Status
        public var count: Int
        public var impactedUsers: Int?
        public var firstOccurrence: Date
        public var lastOccurrence: Date
        public var exception: String?
        public var crashReason: String
        /// Frame belonging to the reason of the crash
        public var reasonFrame: ReasonFrame?
        /// Crash or handled exception
        public var isFatal: Bool
        public var annotation: String

        public enum Status: String, Codable, CaseIterable {
          case `open`
          case closed
          case ignored
        }

        /// Frame belonging to the reason of the crash
        public struct ReasonFrame: Decodable {
          /// Name of the class
          public var className: String?
          /// Name of the method
          public var method: String?
          /// Is a class method
          public var isClassMethod: Bool?
          /// Name of the file
          public var file: String?
          /// Line number
          public var line: Int?
          /// This line isn't from any framework
          public var isAppCode: Bool?
          /// Name of the framework
          public var frameworkName: String?
          /// Formatted frame string
          public var codeFormatted: String?
          /// Unformatted Frame string
          public var codeRaw: String?
          /// Programming language of the frame
          public var language: Language?
          /// Parameters of the frames method
          public var methodParams: String?
          /// Exception type.
          public var exceptionType: String?
          /// OS exception type. (aka. SIGNAL)
          public var osExceptionType: String?

          /// Programming language of the frame
          public enum Language: String, Codable, CaseIterable {
            case javaScript = "JavaScript"
            case cSharp = "CSharp"
            case objectiveC = "Objective-C"
            case objectiveCpp = "Objective-Cpp"
            case cpp = "Cpp"
            case c = "C"
            case swift = "Swift"
            case java = "Java"
            case unknown = "Unknown"
          }

          public init(className: String? = nil, method: String? = nil, isClassMethod: Bool? = nil, file: String? = nil, line: Int? = nil, isAppCode: Bool? = nil, frameworkName: String? = nil, codeFormatted: String? = nil, codeRaw: String? = nil, language: Language? = nil, methodParams: String? = nil, exceptionType: String? = nil, osExceptionType: String? = nil) {
            self.className = className
            self.method = method
            self.isClassMethod = isClassMethod
            self.file = file
            self.line = line
            self.isAppCode = isAppCode
            self.frameworkName = frameworkName
            self.codeFormatted = codeFormatted
            self.codeRaw = codeRaw
            self.language = language
            self.methodParams = methodParams
            self.exceptionType = exceptionType
            self.osExceptionType = osExceptionType
          }

          public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.className = try values.decodeIfPresent(String.self, forKey: "class_name")
            self.method = try values.decodeIfPresent(String.self, forKey: "method")
            self.isClassMethod = try values.decodeIfPresent(Bool.self, forKey: "class_method")
            self.file = try values.decodeIfPresent(String.self, forKey: "file")
            self.line = try values.decodeIfPresent(Int.self, forKey: "line")
            self.isAppCode = try values.decodeIfPresent(Bool.self, forKey: "app_code")
            self.frameworkName = try values.decodeIfPresent(String.self, forKey: "framework_name")
            self.codeFormatted = try values.decodeIfPresent(String.self, forKey: "code_formatted")
            self.codeRaw = try values.decodeIfPresent(String.self, forKey: "code_raw")
            self.language = try values.decodeIfPresent(Language.self, forKey: "language")
            self.methodParams = try values.decodeIfPresent(String.self, forKey: "method_params")
            self.exceptionType = try values.decodeIfPresent(String.self, forKey: "exception_type")
            self.osExceptionType = try values.decodeIfPresent(String.self, forKey: "os_exception_type")
          }
        }

        public init(crashGroupID: String, newCrashGroupID: String, displayID: String, appVersion: String, build: String, status: Status, count: Int, impactedUsers: Int? = nil, firstOccurrence: Date, lastOccurrence: Date, exception: String? = nil, crashReason: String, reasonFrame: ReasonFrame? = nil, isFatal: Bool, annotation: String) {
          self.crashGroupID = crashGroupID
          self.newCrashGroupID = newCrashGroupID
          self.displayID = displayID
          self.appVersion = appVersion
          self.build = build
          self.status = status
          self.count = count
          self.impactedUsers = impactedUsers
          self.firstOccurrence = firstOccurrence
          self.lastOccurrence = lastOccurrence
          self.exception = exception
          self.crashReason = crashReason
          self.reasonFrame = reasonFrame
          self.isFatal = isFatal
          self.annotation = annotation
        }

        public init(from decoder: Decoder) throws {
          let values = try decoder.container(keyedBy: StringCodingKey.self)
          self.crashGroupID = try values.decode(String.self, forKey: "crash_group_id")
          self.newCrashGroupID = try values.decode(String.self, forKey: "new_crash_group_id")
          self.displayID = try values.decode(String.self, forKey: "display_id")
          self.appVersion = try values.decode(String.self, forKey: "app_version")
          self.build = try values.decode(String.self, forKey: "build")
          self.status = try values.decode(Status.self, forKey: "status")
          self.count = try values.decode(Int.self, forKey: "count")
          self.impactedUsers = try values.decodeIfPresent(Int.self, forKey: "impacted_users")
          self.firstOccurrence = try values.decode(Date.self, forKey: "first_occurrence")
          self.lastOccurrence = try values.decode(Date.self, forKey: "last_occurrence")
          self.exception = try values.decodeIfPresent(String.self, forKey: "exception")
          self.crashReason = try values.decode(String.self, forKey: "crash_reason")
          self.reasonFrame = try values.decodeIfPresent(ReasonFrame.self, forKey: "reason_frame")
          self.isFatal = try values.decode(Bool.self, forKey: "fatal")
          self.annotation = try values.decode(String.self, forKey: "annotation")
        }
      }

      public init(isLimitedResultSet: Bool, continuationToken: String? = nil, crashGroups: [CrashGroup]) {
        self.isLimitedResultSet = isLimitedResultSet
        self.continuationToken = continuationToken
        self.crashGroups = crashGroups
      }

      public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.isLimitedResultSet = try values.decode(Bool.self, forKey: "limited_result_set")
        self.continuationToken = try values.decodeIfPresent(String.self, forKey: "continuation_token")
        self.crashGroups = try values.decode([CrashGroup].self, forKey: "crash_groups")
      }
    }

    public struct GetParameters {
      public var lastOccurrenceFrom: Date?
      public var lastOccurrenceTo: Date?
      public var appVersion: String?
      public var groupType: GroupType?
      public var groupStatus: GroupStatus?
      public var groupTextSearch: String?
      public var orderby: Orderby?
      public var continuationToken: String?

      public enum GroupType: String, Codable, CaseIterable {
        case groupType1 = "GroupType1"
        case groupType2 = "GroupType2"
      }

      public enum GroupStatus: String, Codable, CaseIterable {
        case `open`
        case closed
        case ignored
      }

      public enum Orderby: String, Codable, CaseIterable {
        case lastOccurrenceAsc = "last_occurrence asc"
        case lastOccurrenceDesc = "last_occurrence desc"
        case countAsc = "count asc"
        case countDesc = "count desc"
        case displayIDAsc = "display_id asc"
        case displayIDDesc = "display_id desc"
        case impactedUsersAsc = "impacted_users asc"
        case impactedUsersDesc = "impacted_users desc"
      }

      public init(lastOccurrenceFrom: Date? = nil, lastOccurrenceTo: Date? = nil, appVersion: String? = nil, groupType: GroupType? = nil, groupStatus: GroupStatus? = nil, groupTextSearch: String? = nil, orderby: Orderby? = nil, continuationToken: String? = nil) {
        self.lastOccurrenceFrom = lastOccurrenceFrom
        self.lastOccurrenceTo = lastOccurrenceTo
        self.appVersion = appVersion
        self.groupType = groupType
        self.groupStatus = groupStatus
        self.groupTextSearch = groupTextSearch
        self.orderby = orderby
        self.continuationToken = continuationToken
      }

      public var asQuery: [(String, String?)] {
        let encoder = URLQueryEncoder()
        encoder.encode(lastOccurrenceFrom, forKey: "last_occurrence_from")
        encoder.encode(lastOccurrenceTo, forKey: "last_occurrence_to")
        encoder.encode(appVersion, forKey: "app_version")
        encoder.encode(groupType, forKey: "group_type")
        encoder.encode(groupStatus, forKey: "group_status")
        encoder.encode(groupTextSearch, forKey: "group_text_search")
        encoder.encode(orderby, forKey: "$orderby")
        encoder.encode(continuationToken, forKey: "continuation_token")
        return encoder.items
      }
    }
  }
}
