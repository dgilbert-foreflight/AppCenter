// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension API.Apps.WithOwnerName.WithAppName.Releases {
  public func releaseID(_ releaseID: String) -> WithReleaseID {
    WithReleaseID(path: "\(path)/\(releaseID)")
  }

  public struct WithReleaseID {
    /// Path: `/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}`
    public let path: String

    /// Get a release with id `release_id`. If `release_id` is `latest`, return the latest release that was distributed to the current user (from all the distribution groups).
    public func get(udid: String? = nil, isInstallPage: Bool? = nil) -> Request<[String: AnyJSON]> {
      Request(method: "GET", url: path, query: makeGetQuery(udid, isInstallPage), id: "releases_getLatestByUser")
    }

    private func makeGetQuery(_ udid: String?, _ isInstallPage: Bool?) -> [(String, String?)] {
      let encoder = URLQueryEncoder()
      encoder.encode(udid, forKey: "udid")
      encoder.encode(isInstallPage, forKey: "is_install_page")
      return encoder.items
    }

    /// Update details of a release.
    public func put(_ body: PutRequest) -> Request<[String: AnyJSON]> {
      Request(method: "PUT", url: path, body: body, id: "releases_updateDetails")
    }

    /// A request containing information for updating details of a release
    public struct PutRequest: Encodable {
      /// Toggle this release to be enable distribute/download or not.
      public var isEnabled: Bool?
      /// Release notes for this release.
      public var releaseNotes: String?
      /// Contains metadata about the build that produced the release being uploaded
      public var build: Build?

      /// Contains metadata about the build that produced the release being uploaded
      public struct Build: Encodable {
        /// The branch name of the build producing the release
        public var branchName: String?
        /// The commit hash of the build producing the release
        public var commitHash: String?
        /// The commit message of the build producing the release
        public var commitMessage: String?

        public init(branchName: String? = nil, commitHash: String? = nil, commitMessage: String? = nil) {
          self.branchName = branchName
          self.commitHash = commitHash
          self.commitMessage = commitMessage
        }

        public func encode(to encoder: Encoder) throws {
          var values = encoder.container(keyedBy: StringCodingKey.self)
          try values.encodeIfPresent(branchName, forKey: "branch_name")
          try values.encodeIfPresent(commitHash, forKey: "commit_hash")
          try values.encodeIfPresent(commitMessage, forKey: "commit_message")
        }
      }

      public init(isEnabled: Bool? = nil, releaseNotes: String? = nil, build: Build? = nil) {
        self.isEnabled = isEnabled
        self.releaseNotes = releaseNotes
        self.build = build
      }

      public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(isEnabled, forKey: "enabled")
        try values.encodeIfPresent(releaseNotes, forKey: "release_notes")
        try values.encodeIfPresent(build, forKey: "build")
      }
    }

    /// Updates a release.
    public func patch(_ body: String) -> Request<[String: AnyJSON]> {
      Request(method: "PATCH", url: path, body: body, id: "releases_update")
    }

    /// Deletes a release.
    public var delete: Request<Void> {
      Request(method: "DELETE", url: path, id: "releases_delete")
    }
  }
}
