// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension API.Apps.WithOwnerName.WithAppName.DistributionStores.WithStoreName {
  public var latestRelease: LatestRelease {
    LatestRelease(path: path + "/latest_release")
  }

  public struct LatestRelease {
    /// Path: `/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/latest_release`
    public let path: String

    /// Returns the latest release published in a store.
    public var get: Request<[GetResponseItem]> {
      Request(method: "GET", url: path, id: "storeReleases_getLatest")
    }

    /// Details of an uploaded release
    public struct GetResponseItem: Decodable, Identifiable {
      /// ID identifying this unique release.
      public var id: Double?
      /// OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>
      /// The release state.<br>
      /// <b>available</b>: The uploaded release has been distributed.<br>
      /// <b>unavailable</b>: The uploaded release is not visible to the user. <br>
      public var status: Status?
      /// The app's name (extracted from the uploaded release).
      public var appName: String?
      /// The app's display name.
      public var appDisplayName: String?
      /// The release's version.<br>
      /// For iOS: CFBundleVersion from info.plist.
      /// For Android: android:versionCode from AppManifest.xml.
      public var version: String?
      /// The release's short version.<br>
      /// For iOS: CFBundleShortVersionString from info.plist.
      /// For Android: android:versionName from AppManifest.xml.
      public var shortVersion: String?
      /// The release's release notes.
      public var releaseNotes: String?
      /// The release's size in bytes.
      public var size: Double?
      /// The release's minimum required operating system.
      public var minOs: String?
      /// The release's minimum required Android API level.
      public var androidMinAPILevel: String?
      /// The identifier of the apps bundle.
      public var bundleIdentifier: String?
      /// MD5 checksum of the release binary.
      public var fingerprint: String?
      /// UTC time in ISO 8601 format of the uploaded time.
      public var uploadedAt: String?
      /// The URL that hosts the binary for this release.
      public var downloadURL: String?
      /// The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`
      public var installURL: InstallURL?
      /// A list of distribution stores that are associated with this release.
      public var distributionStores: [DistributionStore]?

      /// OBSOLETE. Will be removed in next version. The availability concept is now replaced with distributed. Any 'available' release will be associated with the default distribution group of an app.</br>
      /// The release state.<br>
      /// <b>available</b>: The uploaded release has been distributed.<br>
      /// <b>unavailable</b>: The uploaded release is not visible to the user. <br>
      public enum Status: String, Codable, CaseIterable {
        case available
        case unavailable
      }

      /// The href required to install a release on a mobile device. On iOS devices will be prefixed with `itms-services://?action=download-manifest&url=`
      public enum InstallURL: String, Codable, CaseIterable {
        case group
        case store
      }

      public struct DistributionStore: Decodable, Identifiable {
        /// ID identifying a unique distribution store.
        public var id: String?
        /// A name identifying a unique distribution store.
        public var name: String?
        /// Type of the distribution store currently stores type can be intune or googleplay.
        public var type: `Type`?
        /// Publishing status of the release in the store.
        public var publishingStatus: String?

        /// Type of the distribution store currently stores type can be intune or googleplay.
        public enum `Type`: String, Codable, CaseIterable {
          case intune
          case googleplay
        }

        public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, publishingStatus: String? = nil) {
          self.id = id
          self.name = name
          self.type = type
          self.publishingStatus = publishingStatus
        }

        public init(from decoder: Decoder) throws {
          let values = try decoder.container(keyedBy: StringCodingKey.self)
          self.id = try values.decodeIfPresent(String.self, forKey: "id")
          self.name = try values.decodeIfPresent(String.self, forKey: "name")
          self.type = try values.decodeIfPresent(`Type`.self, forKey: "type")
          self.publishingStatus = try values.decodeIfPresent(String.self, forKey: "publishing_status")
        }
      }

      public init(id: Double? = nil, status: Status? = nil, appName: String? = nil, appDisplayName: String? = nil, version: String? = nil, shortVersion: String? = nil, releaseNotes: String? = nil, size: Double? = nil, minOs: String? = nil, androidMinAPILevel: String? = nil, bundleIdentifier: String? = nil, fingerprint: String? = nil, uploadedAt: String? = nil, downloadURL: String? = nil, installURL: InstallURL? = nil, distributionStores: [DistributionStore]? = nil) {
        self.id = id
        self.status = status
        self.appName = appName
        self.appDisplayName = appDisplayName
        self.version = version
        self.shortVersion = shortVersion
        self.releaseNotes = releaseNotes
        self.size = size
        self.minOs = minOs
        self.androidMinAPILevel = androidMinAPILevel
        self.bundleIdentifier = bundleIdentifier
        self.fingerprint = fingerprint
        self.uploadedAt = uploadedAt
        self.downloadURL = downloadURL
        self.installURL = installURL
        self.distributionStores = distributionStores
      }

      public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decodeIfPresent(Double.self, forKey: "id")
        self.status = try values.decodeIfPresent(Status.self, forKey: "status")
        self.appName = try values.decodeIfPresent(String.self, forKey: "app_name")
        self.appDisplayName = try values.decodeIfPresent(String.self, forKey: "app_display_name")
        self.version = try values.decodeIfPresent(String.self, forKey: "version")
        self.shortVersion = try values.decodeIfPresent(String.self, forKey: "short_version")
        self.releaseNotes = try values.decodeIfPresent(String.self, forKey: "release_notes")
        self.size = try values.decodeIfPresent(Double.self, forKey: "size")
        self.minOs = try values.decodeIfPresent(String.self, forKey: "min_os")
        self.androidMinAPILevel = try values.decodeIfPresent(String.self, forKey: "android_min_api_level")
        self.bundleIdentifier = try values.decodeIfPresent(String.self, forKey: "bundle_identifier")
        self.fingerprint = try values.decodeIfPresent(String.self, forKey: "fingerprint")
        self.uploadedAt = try values.decodeIfPresent(String.self, forKey: "uploaded_at")
        self.downloadURL = try values.decodeIfPresent(String.self, forKey: "download_url")
        self.installURL = try values.decodeIfPresent(InstallURL.self, forKey: "install_url")
        self.distributionStores = try values.decodeIfPresent([DistributionStore].self, forKey: "distribution_stores")
      }
    }
  }
}
